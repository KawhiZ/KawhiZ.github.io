<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kawhiz.github.io/"/>
  <updated>2020-07-05T13:20:32.560Z</updated>
  <id>https://kawhiz.github.io/</id>
  
  <author>
    <name>庄健彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL连接1130问题</title>
    <link href="https://kawhiz.github.io/2020/07/05/MySQL%E8%BF%9E%E6%8E%A51130%E9%97%AE%E9%A2%98/"/>
    <id>https://kawhiz.github.io/2020/07/05/MySQL%E8%BF%9E%E6%8E%A51130%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-05T13:12:23.000Z</published>
    <updated>2020-07-05T13:20:32.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>mysql连接时报1130-Host ‘localhost’ is not allowed to connect to this MySQL server</strong></p><a id="more"></a><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p><strong>主要就是localhost莫名奇妙连接时没有权限可以登录，所以想办法跳过权限表登录</strong></p><ul><li>关闭mysql服务<br><code>net stop mysql</code><br><img src="/2020/07/05/MySQL%E8%BF%9E%E6%8E%A51130%E9%97%AE%E9%A2%98/20200705091857318.png" alt></li><li>先到mysql安装目录执行跳过权限表登录命令<br><code>mysqld --skip-grant-tables</code><br><img src="/2020/07/05/MySQL%E8%BF%9E%E6%8E%A51130%E9%97%AE%E9%A2%98/20200705091601822.png" alt></li><li>登录root用户<br><code>mysql -u root -p</code><br><img src="/2020/07/05/MySQL%E8%BF%9E%E6%8E%A51130%E9%97%AE%E9%A2%98/20200705091942801.png" alt></li><li>最后重新打开mysql服务即可<br><code>net start mysql</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;mysql连接时报1130-Host ‘localhost’ is not allowed to connect to this MySQL server&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://kawhiz.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>plsql一条龙安装配置</title>
    <link href="https://kawhiz.github.io/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://kawhiz.github.io/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-01T07:14:21.000Z</published>
    <updated>2020-07-01T08:03:52.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>win10、plsqldeveloper11_x64、instantclient_11_2<a id="more"></a><h1 id="安装plsql"><a href="#安装plsql" class="headerlink" title="安装plsql"></a>安装plsql</h1></li><li>傻瓜式安装</li><li>安装完成打开后如图进行破解（使用sql development key gen）<br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701032408259.png" alt></li><li>按需汉化（使用对应汉化包）<br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701032604177.png" alt><h1 id="几个变量的配置"><a href="#几个变量的配置" class="headerlink" title="几个变量的配置"></a>几个变量的配置</h1><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701032652638.png" alt><br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701032749836.png" alt><br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701032905203.png" alt><br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701033114025.png" alt><h1 id="具体连接配置"><a href="#具体连接配置" class="headerlink" title="具体连接配置"></a>具体连接配置</h1><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701033504007.png" alt><h1 id="网络ip的配置"><a href="#网络ip的配置" class="headerlink" title="网络ip的配置"></a>网络ip的配置</h1><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701033713563.png" alt><h1 id="查看路由配置"><a href="#查看路由配置" class="headerlink" title="查看路由配置"></a>查看路由配置</h1></li><li>管理员身份打开cmd<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipconfig # 查看网络ip配置等</span><br><span class="line">route print # 查看路由配置</span><br><span class="line">route add 0.0.0.0 mask 0.0.0.0 192.168.1.1 -p # 添加无线网卡ip配置，让所有请求走无线网卡ip</span><br><span class="line">route add xxx.xxx.xxx.xxx mask xxx.xxx.xxx.xxx 目标ip -p # 按需指定以太网请求ip</span><br></pre></td></tr></table></figure></li><li><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701034048173.png" alt><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1></li><li>能否ping通指定数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &quot;ip&quot;</span><br></pre></td></tr></table></figure></li><li>查看能否登录成功<br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701034832961.png" alt><br><img src="/2020/07/01/plsql%E4%B8%80%E6%9D%A1%E9%BE%99%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20200701034947861.png" alt><h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1></li><li>连接遇到ora-12170</li><li><em>一开始还是比较头疼，后来ping 数据库host、ip配置检查，我一开始是遇到前面以太网内网ip配置ip冲突，所以无法ping通。。。*</em></li><li>连接遇到can’t reach</li><li><em>如果不能上网检查交换机路由器网线等配置逐一排查*</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;win10、plsqldeveloper11_x64、instantclient_11_2&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://kawhiz.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MySQL连接10061问题</title>
    <link href="https://kawhiz.github.io/2020/06/29/MySQL%E8%BF%9E%E6%8E%A510061%E9%97%AE%E9%A2%98/"/>
    <id>https://kawhiz.github.io/2020/06/29/MySQL%E8%BF%9E%E6%8E%A510061%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-29T06:49:47.000Z</published>
    <updated>2020-07-05T13:13:10.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul><li>莫名奇妙连接不上mysql，但是mysql服务是打开的<a id="more"></a><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1></li><li>启动mysql镜像<br><img src="/2020/06/29/MySQL%E8%BF%9E%E6%8E%A510061%E9%97%AE%E9%A2%98/20200629025224974.png" alt></li><li>重新再打开一个同目录的powershell路径同上进入<br><img src="/2020/06/29/MySQL%E8%BF%9E%E6%8E%A510061%E9%97%AE%E9%A2%98/20200629025422538.png" alt></li><li>输入修改root密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set password&#x3D;&#39;设置好的密码&#39; where User&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;莫名奇妙连接不上mysql，但是mysql服务是打开的&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://kawhiz.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6网络配置</title>
    <link href="https://kawhiz.github.io/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://kawhiz.github.io/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-18T07:33:38.000Z</published>
    <updated>2020-05-18T08:03:46.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p><strong>CentOS6.3、Window10专业版、VMware8.0.4</strong></p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p><strong>虚拟机联网</strong></p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li>傻瓜式安装VMware、同时装上CentOS系统、按需打上汉化</li><li>确认win10中VMware相关服务是否打开<br><img src="/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/20200518034215334.png" alt></li><li>确认NAT配置信息<br><img src="/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/20200518034827601.png" alt></li><li>确认虚拟路由器信息<br><img src="/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/20200518034653138.png" alt></li><li>配置网络端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-eth0</span><br></pre></td></tr></table></figure></li><li><em>按a或i进入编辑模式*</em><br>修改信息：<br>ONBOOT=yes<br>BOOTPROTO=static<br>添加信息：<br>IPADDR=192.168.23.100（<strong>根据网关自行调整,前面确认的地址</strong>）<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.23.2</li><li><em>vi编辑完成后:wq保存退出即可*</em></li><li>重启网络配置并查看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service network restart # 重启</span><br><span class="line">ifconfig # 查看eth0中192.168.23.100是否配置成功</span><br></pre></td></tr></table></figure></li><li>注意关闭Win10、和CentOS中的防火墙【非常重要】<br><img src="/2020/05/18/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/20200518035626187.png" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop # 即时生效，打开对应start，查看当前状态对应status</span><br><span class="line">chkconfig iptables off # 重启生效，打开对应stop</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1></li><li>在虚拟机中测试网络是否联通（如果ping不同查看两端是否关闭防火墙）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.23.2 # ping虚拟网关</span><br><span class="line">ping 192.168.23.1 # ping虚拟Win10地址</span><br><span class="line">ping www.baidu.com # ping外网</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;CentOS6.3、Window10专业版、VMware8.0.4&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;虚拟机联网&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://kawhiz.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>课程表II</title>
    <link href="https://kawhiz.github.io/2020/05/17/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/"/>
    <id>https://kawhiz.github.io/2020/05/17/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/</id>
    <published>2020-05-17T11:32:12.000Z</published>
    <updated>2020-05-17T12:04:57.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/course-schedule-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-ii</a> 】<br>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1:<br>输入: 2, [[1,0]]<br>输出: [0,1]<br>解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p><p>示例 2:<br>输入: 4, [[1,0],[2,0],[3,1],[3,2]]<br>输出: [0,1,2,3] or [0,2,1,3]<br>解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p><p>说明:<br>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。</p><p>提示:<br>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>参考官方解题思路【<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/】，有几个关键问题：" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/】，有几个关键问题：</a><br>（1）如何将二维数组进行转换方便解题？每个一维数组相当于图的相邻有向关系<br>（2）如果找出选所有课程顺序？可以发现如果存在类似死锁的环关系，比如用例【0，1】【1，0】那么无法进行拓扑排序<br>（3）将构成的图对每个结点进行bfs搜索，那么入队条件是什么？借助队列和入度统计来进行辅助判断，注意关系【1，0】代表必须先选0再选1，那么统计入度的关键：for(int[] temp : prerequisites) {count[temp[0]]++;}<br>（4）bfs出队时需要进行什么操作？出队同时需要修改结点的入度数目，再将新的入度为0的结点入队继续哦按段<br>（5）存在类似死锁的关系循环如何判断？存在死循环那么代表无法选满所有课<br>（6）以示例2关系构图如图</strong><br><img src="/2020/05/17/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/20200517075555185.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        &#x2F;&#x2F; 统计每个结点的入度，count[i]代表课程i的入度数</span><br><span class="line">        int[] count &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F; 存放拓扑排序的结果</span><br><span class="line">        int[] res &#x3D; new int[numCourses];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 辅助队列</span><br><span class="line">        LinkedList&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 统计入度数的关键代码</span><br><span class="line">        for(int[] temp : prerequisites) &#123;</span><br><span class="line">            count[temp[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将入度数为0的入队</span><br><span class="line">        for(int i &#x3D; 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if(count[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 选课顺序下标</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前选课</span><br><span class="line">            int curNum &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 更新选课顺序</span><br><span class="line">            res[index++] &#x3D; curNum;</span><br><span class="line">            &#x2F;&#x2F; 遍历所有选择关系</span><br><span class="line">            for(int[] temp : prerequisites) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个先修关系</span><br><span class="line">                if(temp[1] &#x3D;&#x3D; curNum) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 当前课程对应后修课程入度减一</span><br><span class="line">                    count[temp[0]]--;</span><br><span class="line">                    &#x2F;&#x2F; 将入度为一的课程结点入队</span><br><span class="line">                    if(count[temp[0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        queue.offer(temp[0]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果存在类似死锁的环则返回空数组</span><br><span class="line">        return index &#x3D;&#x3D; numCourses ? res : new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/17/%E8%AF%BE%E7%A8%8B%E8%A1%A8II/20200517073405182.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/course-schedule-ii&lt;/a&gt; 】&lt;br&gt;现在你总共有 n 门课需要选，记为 0 到 n-1。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。&lt;/p&gt;
&lt;p&gt;可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 2, [[1,0]]&lt;br&gt;输出: [0,1]&lt;br&gt;解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: 4, [[1,0],[2,0],[3,1],[3,2]]&lt;br&gt;输出: [0,1,2,3] or [0,2,1,3]&lt;br&gt;解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。&lt;br&gt;     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。&lt;br&gt;你可以假定输入的先决条件中没有重复的边。&lt;/p&gt;
&lt;p&gt;提示:&lt;br&gt;这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。&lt;br&gt;通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。&lt;br&gt;拓扑排序也可以通过 BFS 完成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>x的平方根</title>
    <link href="https://kawhiz.github.io/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://kawhiz.github.io/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</id>
    <published>2020-05-08T19:46:46.000Z</published>
    <updated>2020-05-08T20:06:17.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx</a> 】</p><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br>输入: 4<br>输出: 2</p><p>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>当前我们可以使用库函数Math.sqrt(x)或者Math.pow(x, 0.5)，如果不借助库函数的话则在数目不大的情况下可以直接从1开始枚举，找到一个临界即可，注意int的边界问题即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x &#x3D;&#x3D; 2147483647) &#123;</span><br><span class="line">            return 46340;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 直接暴力枚举</span><br><span class="line">        while(i &lt; x) &#123;</span><br><span class="line">            if(i * i &#x3D;&#x3D; x) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125; else if(i * i &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i - 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/20200509035333879.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>数目多的情况下在有序数列中自然而然可以使用二分搜索来提高效率，注意一下int越界的问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; x;</span><br><span class="line">        int res &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 二分查找</span><br><span class="line">        while(low &lt;&#x3D; high) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意这里不写成mid &#x3D; (low + high) &#x2F; 2 是为了当low、high非常大时int不越界</span><br><span class="line">            int mid &#x3D; low + (high - low) &gt;&gt; 1;</span><br><span class="line">            &#x2F;&#x2F; 必须强转为double否则非常容易越界</span><br><span class="line">            if((double)mid * mid &lt;&#x3D; x) &#123;</span><br><span class="line">                res &#x3D; mid;</span><br><span class="line">                low &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/20200509035212671.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/sqrtx&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;实现 int sqrt(int x) 函数。&lt;br&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;br&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 4&lt;br&gt;输出: 2&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: 8&lt;br&gt;输出: 2&lt;br&gt;说明: 8 的平方根是 2.82842…,&lt;br&gt;     由于返回类型是整数，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形</title>
    <link href="https://kawhiz.github.io/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://kawhiz.github.io/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2020-05-08T08:46:42.000Z</published>
    <updated>2020-05-08T09:51:16.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square</a> 】<br>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>找最优解的话优先考虑能否用dp解决，有几个关键<br>（1）要找都为1的最大面积正方形，假如能找到最大的边长再取平方问题即迎刃而解<br>（2）dp(i)(j)代表从(0)(0)到(i)(j)处的最大正方形数目（因为边长为1，也就是最大边长），状态转移式如下：<br>    * 直观可以判断在第0行或者第0列的dp值为原来的值， dp(i)(j) = matrix(i)(j)<br>    * 其他位置值等于左、上、左上最小值加一，核心状态转移式：dp(i)(j) = min(dp(i - 1)(j), dp(i)(j - 1), dp(i - 1)(j - 1)) + 1（matrix(i)(j) == ‘1’）<br>    * dp(i)(j) = 0 (martix(i)(j) == ‘0’)<br>（3）注意char和int的互相转化即可int i，char c = (char)(‘0’ + i)或char c = Character.forDigit(i,10);int i = char - ‘0’</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int maximalSquare(char[][] matrix) &#123;</span><br><span class="line">        int m &#x3D; matrix.length;</span><br><span class="line">        if(m &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; dp[i][j]代表从0， 0到i、j为右下边界的最大边长</span><br><span class="line">        int [][] dp &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 最大边长</span><br><span class="line">        int maxSide &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 初始化</span><br><span class="line">                if(i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 注意原来是char类型</span><br><span class="line">                    dp[i][j] &#x3D; matrix[i][j] - &#39;0&#39;;</span><br><span class="line">                    &#x2F;&#x2F; 核心状态转移式：取其左、上和左上三者最小值加一</span><br><span class="line">                &#125; else if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i- 1][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果是&#39;0&#39;重新修改为0,这一处也可省略，因为本来dp初始化就是0</span><br><span class="line">                if(matrix[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 取每次的最大边长</span><br><span class="line">                maxSide &#x3D; Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记得计算面积</span><br><span class="line">        return maxSide * maxSide;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/20200508044952087.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximal-square&lt;/a&gt; 】&lt;br&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;1 0 1 0 0&lt;br&gt;1 0 1 1 1&lt;br&gt;1 1 1 1 1&lt;br&gt;1 0 0 1 0&lt;/p&gt;
&lt;p&gt;输出: 4&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>另一个树的子树</title>
    <link href="https://kawhiz.github.io/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</id>
    <published>2020-05-07T03:31:22.000Z</published>
    <updated>2020-05-07T04:01:57.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtree-of-another-tree</a> 】<br>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。<br>示例 1:<br>给定的树 s:<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113307497.png" alt><br>给定的树 t：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113318398.png" alt><br>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。<br>示例 2:<br>给定的树 s：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113335803.png" alt><br>给定的树 t：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113345676.png" alt><br>返回 false。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>想要判断一棵树是否是另一个树的子树，可以dfs暴力遍历源树s，再将其跟目标树t通过再一次dfs进行比较是否相等，有几个关键<br>（1）空树是任何树的子树<br>（2）非空树一定不是空树的子树<br>（3）如果判断两颗树相同？只要源子树s中含有跟目标子树t相同的子树结构和值即可，两个指针初始指向两颗树根结点，再同步dfs递归判断<br>（4）因为包含了双递归，特别要注意每次递归的出口，否则非常容易无限递归栈内存溢出。。。</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空树t是任何树的子树</span><br><span class="line">        if(t &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非空树t一定不是空树s的子树</span><br><span class="line">        if(s &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历s结点，同时和t比较是否相同</span><br><span class="line">        return isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断两棵树是否相同</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        &#x2F;&#x2F; 两颗空树相同</span><br><span class="line">        if(p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 空树一定不和非空树结构相同</span><br><span class="line">        if(p &#x3D;&#x3D; null || q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断值是否相等</span><br><span class="line">        if(p.val !&#x3D; q.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 两个指针同步移动判断</span><br><span class="line">        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113215580.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/subtree-of-another-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/subtree-of-another-tree&lt;/a&gt; 】&lt;br&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。&lt;br&gt;示例 1:&lt;br&gt;给定的树 s:&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113307497.png&quot; alt&gt;&lt;br&gt;给定的树 t：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113318398.png&quot; alt&gt;&lt;br&gt;返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。&lt;br&gt;示例 2:&lt;br&gt;给定的树 s：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113335803.png&quot; alt&gt;&lt;br&gt;给定的树 t：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113345676.png&quot; alt&gt;&lt;br&gt;返回 false。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="https://kawhiz.github.io/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-05-05T03:31:29.000Z</published>
    <updated>2020-05-05T04:14:10.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a> 】<br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114201940.png" alt><br><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114212932.png" alt></p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>主要利用BST中序序列为升序这一性质进行验证，可以有递归和辅助栈迭代判断两种思路，几个关键：<br>（1）BST性质中结点是严格大于左子树结点，严格小于右子数结点，即不存在等于的情况<br>（2）树还是尽量采用递归，代码比较清晰易懂，利用辅助栈迭代容易出错</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 存放中序遍历结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        &#x2F;&#x2F; 判断中序遍历是否为升序</span><br><span class="line">        for(int i &#x3D; 1; i &lt; list.size(); i++) &#123;</span><br><span class="line">            if(list.get(i) &lt;&#x3D; list.get(i - 1)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 递归实现中序遍历，结果存放数组</span><br><span class="line">    public void dfs(TreeNode node) &#123;</span><br><span class="line">        &#x2F;&#x2F; 搜索左子树</span><br><span class="line">        if(node.left !&#x3D; null) &#123;</span><br><span class="line">            dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        &#x2F;&#x2F; 搜索右子树</span><br><span class="line">        if(node.right !&#x3D; null) &#123;</span><br><span class="line">            dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114233057.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>辅助栈迭代的中序遍历实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F; 非递归利用栈迭代实现中序遍历</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 测试用例的边界包含Integer.MAX_VALUE,所以要使用double</span><br><span class="line">        double preNodeVal &#x3D; - Double.MAX_VALUE;</span><br><span class="line">        TreeNode curNode &#x3D; root;</span><br><span class="line">        while(!stack.isEmpty() || curNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 未到底一直将左子结点入栈</span><br><span class="line">            while(curNode !&#x3D; null) &#123;</span><br><span class="line">                stack.push(curNode);</span><br><span class="line">                curNode &#x3D; curNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 到底了弹出</span><br><span class="line">            curNode &#x3D; stack.pop();</span><br><span class="line">            &#x2F;&#x2F; 如果不满足</span><br><span class="line">            if(curNode.val &lt;&#x3D; preNodeVal) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 更新中序遍历前一节点值</span><br><span class="line">            preNodeVal &#x3D; curNode.val;</span><br><span class="line">            &#x2F;&#x2F; 更新当前结点</span><br><span class="line">            curNode &#x3D; curNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505121054198.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/validate-binary-search-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/validate-binary-search-tree&lt;/a&gt; 】&lt;br&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;假设一个二叉搜索树具有如下特征：&lt;br&gt;节点的左子树只包含小于当前节点的数。&lt;br&gt;节点的右子树只包含大于当前节点的数。&lt;br&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;br&gt;&lt;img src=&quot;/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114201940.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114212932.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏II</title>
    <link href="https://kawhiz.github.io/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>https://kawhiz.github.io/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2020-05-04T02:17:53.000Z</published>
    <updated>2020-05-04T02:33:41.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii</a> 】</p><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:<br>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>说明:<br>假设你总是可以到达数组的最后一个位置。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>从目的地最后的位置来看，倒数前一次跳跃每次如果每次能找到一个离起点更近的位置则可以节省步数，最后找到起始位置即可，几个关键问题<br>（1）注意在找到一个位置后更新跳跃倒数前一个位置以及跳出循环<br>（2）外层循环是到起始位置则结束</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最少跳跃步数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 初始为最后的位置</span><br><span class="line">        int pos &#x3D; n - 1;</span><br><span class="line">        &#x2F;&#x2F; 找到初始位置则结束</span><br><span class="line">        while (pos &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从左往右贪心地选择离最后位置最远的地方</span><br><span class="line">            for (int i &#x3D; 0; i &lt; pos; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果可达</span><br><span class="line">                if (i + nums[i] &gt;&#x3D; pos) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    &#x2F;&#x2F; 更新跳跃倒数前一个位置</span><br><span class="line">                    pos &#x3D; i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/20200504102947332.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>从起始位置来看，每次选择能跳跃的更远的位置来考虑下一步跳跃则可以节省步数，最后到达目的地即可，有几个关键<br>（1）如何实现？这种思路起始很容易想到，但是实际还是不容易想到设置一个边界来实现，每次到达边界则更新边界<br>（2）最后的位置不需要遍历，必定能到达最后的位置不用再跳</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最少跳跃步数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 当前最远跳跃位置</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 边界</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意不需要遍历到最后一个元素</span><br><span class="line">        for(int cur &#x3D; 0; cur &lt; n - 1; cur++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最大跳跃位置</span><br><span class="line">            curMax &#x3D; Math.max(curMax, cur + nums[cur]);</span><br><span class="line">            &#x2F;&#x2F; 到达边界则更新边界和跳跃步数</span><br><span class="line">            if(cur &#x3D;&#x3D; end) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                end &#x3D; curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/20200504102449553.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/jump-game-ii&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;你的目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [2,3,1,1,4]&lt;br&gt;输出: 2&lt;br&gt;解释: 跳到最后一个位置的最小跳跃数是 2。&lt;br&gt;     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。&lt;br&gt;说明:&lt;br&gt;假设你总是可以到达数组的最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大子序和</title>
    <link href="https://kawhiz.github.io/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>https://kawhiz.github.io/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2020-05-03T06:33:16.000Z</published>
    <updated>2020-05-03T07:15:53.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a> 】<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>进阶:<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>为了在O（n）时间内肯定没法尝试双重循环暴力求解，那么因为为了使累加和最大，肯定是尽可能的加上正数，如果之前的累加和已经小于零，代表前面含有负数直接舍弃，否则继续尝试累加找最大值<br>贪心思想：如果之前的累加和小于零，则舍弃之前的数列，累加和则是当前位置的数，否则累加上当前位置的数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    &#x2F;&#x2F; 空数组返回0</span><br><span class="line">    if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 只有一个最大子序和为本身</span><br><span class="line">    int res &#x3D; nums[0];</span><br><span class="line">    &#x2F;&#x2F; 累加和</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 贪心思想：若当前位置之前的和小于零，则丢弃之前的数列</span><br><span class="line">    for(int num : nums) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前累加和大于零</span><br><span class="line">        if(sum &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 则可以继续累加下一个数待判断</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            &#x2F;&#x2F; 丢弃当前位置之前的数列，指望下一个数来使得当前子序和最大</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum &#x3D; num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 取最大子序和</span><br><span class="line">        res &#x3D; Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/20200503024233277.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>怎么说呢，不同于一般dp，之前一般都是返回dp中的最后一位较多，这里仍需取最大值，跟前面贪心类似，可能更清晰易懂，问题的关键：<br>（1）dpi代表前i位的最大累加和<br>（2）动态规划思想：若前一位置为正数，将其加到当前位置上<br>（3）状态转移式dp(i) = nums(i) + dp(i - 1)（dp(i - 1) &gt; 0）、dp（i） = nums(i)(dp(i - 1) &lt;= 0)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 空数组返回0</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        int [] dp &#x3D; new int[n];</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        int res &#x3D; nums[0];</span><br><span class="line">        &#x2F;&#x2F; i从1开始</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果前一位大于零，则继续累加到当前位置上</span><br><span class="line">            if(dp[i - 1] &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 状态转移式</span><br><span class="line">                dp[i] &#x3D; nums[i] + dp[i - 1];</span><br><span class="line">                &#x2F;&#x2F; 否则保持不变</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 取最大值</span><br><span class="line">            res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/20200503031552608.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-subarray&lt;/a&gt; 】&lt;br&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符子串的最长子串</title>
    <link href="https://kawhiz.github.io/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://kawhiz.github.io/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2020-05-02T04:08:18.000Z</published>
    <updated>2020-05-02T04:28:13.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a> 】</p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>参照官方的思路【<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/】，有几个关键问题" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/】，有几个关键问题</a><br>（1）如何对子串中字符判重？注意子串必须是连续的，使用HshSet可以很好解决<br>（2）如何做到比暴力枚举所有情况更优？子串问题常见的滑动窗口双指针问题，一个指向起始位置，一个指向结束位置，如果结束位置未到尾且没有和当前子串重复的字符则一直向右扩大当前窗口长度，否则记录最大长度<br>（3）为什么在左指针向右移动的时候，我们需要从哈希集合中移除一个字符，同时在右指针向右移动的时候，我们需要往哈希集合中添加一个字符呢？前者从窗口位置很直观看出，起始位置移动后，当前子串不包含该位置字符了，判重也不需要考虑该位置，后者是因为我们要找一个最长且不重复的子串<br>（4）子串长度如何计算？当前不重复子串长度很明显就是窗口长度，即结束位置end - 起始位置start</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        &#x2F;&#x2F; 空字符</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 长度为1的字符</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 子串结束的位置</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 无重复最长子串长度</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; set判重</span><br><span class="line">        HashSet&lt;Character&gt; set &#x3D; new HashSet&lt;Character&gt;();</span><br><span class="line">        for (int start &#x3D; 0; start &lt; n; start++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 滑动窗口起始位置右移注意移除前一个起始位置里set字符</span><br><span class="line">            if (start !&#x3D; 0) &#123;</span><br><span class="line">                set.remove(s.charAt(start - 1));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 未到尾以及当前子串没有重复字符则加入set，同时继续扩大窗口</span><br><span class="line">            while (end &lt; n &amp;&amp; !set.contains(s.charAt(end))) &#123;</span><br><span class="line">                set.add(s.charAt(end));</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 取当前窗口长度最大值即是无重复子串长度的最大值</span><br><span class="line">            res &#x3D; Math.max(res, end - start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/20200502121252902.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “abcabcbb”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: “bbbbb”&lt;br&gt;输出: 1&lt;br&gt;解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;输入: “pwwkew”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。&lt;br&gt;     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://kawhiz.github.io/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://kawhiz.github.io/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-01T03:38:19.000Z</published>
    <updated>2020-05-01T03:59:02.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a> 】</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>合并两个有序链表直观的可以联想到归并排序，但是在链表中合并新链表则可以使用尾插法，有几个关键问题<br>（1）一般都是通过设置空数据域的头指针来指向实际的第一个元素，方便编码<br>（2）注意遍历两条链表时循环条件的判断，存在一条链到尾时则可以跳出循环直接拼接另一条链<br>（3）注意最后返回头指针的下一个结点即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 头指针</span><br><span class="line">        ListNode res &#x3D; new ListNode();</span><br><span class="line">        &#x2F;&#x2F; 尾指针</span><br><span class="line">        ListNode tailer &#x3D; res;</span><br><span class="line">        &#x2F;&#x2F; 类似归并排序过程中使用尾插法</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val) &#123;</span><br><span class="line">                tailer.next &#x3D; l1;</span><br><span class="line">                tailer &#x3D; tailer.next;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tailer.next &#x3D; l2;</span><br><span class="line">                tailer &#x3D; tailer.next;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 一条链到头则直接拼接另一条链即可</span><br><span class="line">        if(l1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            tailer.next &#x3D; l2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tailer.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意从头指针的下一个返回</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/20200501114835981.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists&lt;/a&gt; 】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="https://kawhiz.github.io/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>https://kawhiz.github.io/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/</id>
    <published>2020-04-30T03:37:11.000Z</published>
    <updated>2020-04-30T03:43:27.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a> 】</p><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。<br>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：<br>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>直观的直接去计算每一位的平方和判断是否为一即可，这里主要还是考虑循环跳出条件，这里执行10次仍计算不出来则断言为非快乐数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        while(count &lt; 10) &#123;</span><br><span class="line">            n &#x3D; sum(n);</span><br><span class="line">            count++;</span><br><span class="line">            &#x2F;&#x2F; 若为快乐数则跳出</span><br><span class="line">            if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行10次仍计算不出来断言为非快乐数</span><br><span class="line">        if(count &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算每一位的平方和</span><br><span class="line">    public int sum(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(n !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取最低位</span><br><span class="line">            int temp &#x3D; n % 10;</span><br><span class="line">            &#x2F;&#x2F; 累加平方和</span><br><span class="line">            res +&#x3D; (temp * temp);</span><br><span class="line">            &#x2F;&#x2F; 舍弃最低位</span><br><span class="line">            n &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/20200430113930338.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/happy-number&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/happy-number&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;br&gt;「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。&lt;br&gt;如果 n 是快乐数就返回 True ；不是，则返回 False 。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：19&lt;br&gt;输出：true&lt;br&gt;解释：&lt;br&gt;12 + 92 = 82&lt;br&gt;82 + 22 = 68&lt;br&gt;62 + 82 = 100&lt;br&gt;12 + 02 + 02 = 1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-04-24T04:22:11.000Z</published>
    <updated>2020-04-24T04:40:53.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a> 】<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:<br>输入: [7,5,6,4]<br>输出: 5</p><p>限制：<br>0 &lt;= 数组长度 &lt;= 50000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始直接暴力破解，果不其然超时,后来还是参考了官方题解归并排序的思想，主要有几个关键问题：<br>（1）归并排序为什么就能够在O（nlogn）时间内统计逆序对数目？如果右子数组比左子数组大，那么逆序对就是当前左子数组所有数的和（注意左右子数组都是有序的前提下），以【7，5，6，4】为例，当回溯到【5，7】，【4，6】时5和4比较，4小所以当前含有【5，4】，【7，4】两个逆序对（左子数组的长度）；<br>（2）归并排序中递归分治的出口是什么？很明显就是只有一个元素则必定有序<br>（3）注意当left、right很大时，二分取（left + right） / 2 可能会溢出，所以用int mid = left + (right - left) / 2代替</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reversePairs(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 如果只有0、1个数，则不存在逆序对</span><br><span class="line">        if(n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 临时数组</span><br><span class="line">        int[] temp &#x3D; new int[n];</span><br><span class="line">        return reversePairs(0, n - 1, nums, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    public int reversePairs(int left, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 子数组只有一个必定有序</span><br><span class="line">        if (left &#x3D;&#x3D; right) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 逆序对</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意（left + right） &#x2F; 2 可能会溢出</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 左右两边逆序对数目</span><br><span class="line">        int leftCount &#x3D; reversePairs(left, mid, nums, temp);</span><br><span class="line">        int rightCount &#x3D; reversePairs(mid + 1, right, nums, temp);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 横跨左右逆序对数目</span><br><span class="line">        int crossCount &#x3D; mergeSort(left, mid, right, nums, temp);</span><br><span class="line">        return leftCount + rightCount + crossCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 归并回原数组</span><br><span class="line">     * @param left</span><br><span class="line">     * @param mid</span><br><span class="line">     * @param right</span><br><span class="line">     * @param nums</span><br><span class="line">     * @param temp</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int mergeSort(int left, int mid, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先保存在临时数组</span><br><span class="line">        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 左子数组第一个</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        &#x2F;&#x2F; 右子数组第一个</span><br><span class="line">        int j &#x3D; mid + 1;</span><br><span class="line"></span><br><span class="line">        for (int k &#x3D; left; k &lt;&#x3D; right; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果左边合并结束，只能合并右边</span><br><span class="line">            if (i &#x3D;&#x3D; mid + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 如果右边合并结束，只能合并左边</span><br><span class="line">            &#125; else if (j &#x3D;&#x3D; right + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 如果左边的小则代表不存在逆序对，直接合并</span><br><span class="line">            &#125; else if (temp[i] &lt;&#x3D; temp[j]) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 否则计算逆序对</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 计算的关键代码</span><br><span class="line">                count +&#x3D; (mid - i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/20200424122857899.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&lt;/a&gt; 】&lt;br&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;0 &amp;lt;= 数组长度 &amp;lt;= 50000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-04-20T01:57:56.000Z</published>
    <updated>2020-04-20T02:30:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a> 】<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:<br>输入:<br>11110<br>11010<br>11000<br>00000<br>输出: 1</p><p>示例 2:<br>输入:<br>11000<br>11000<br>00100<br>00011<br>输出: 3<br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>比较经典的题目，仍然采用bfs的一般思路，遍历二维数组，找到一个陆地入队，设置已访问，对陆地周围进行搜索，符合条件入队，再设置已访问，有几个注意的点<br>（1）注意初始二维数组类型是char而不是int<br>（2）注意每次搜索完必须设置已访问，这里可以直接将访问过位置设置为’0’或者其他标记均可（设置成零的话执行是最快的），这里无需额外开一个数组记录<br>（3）注意岛屿的数目即是bfs搜索的次数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 岛屿数加一</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    &#x2F;&#x2F; 陆地入队</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 陆地访问过则置为&#39;0&#39;</span><br><span class="line">                    grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">                    while(!queue.isEmpty()) &#123;</span><br><span class="line">                        int[] point &#x3D; queue.poll();</span><br><span class="line">                        &#x2F;&#x2F; 当前横坐标</span><br><span class="line">                        int x &#x3D; point[0];</span><br><span class="line">                        &#x2F;&#x2F; 当前纵坐标</span><br><span class="line">                        int y &#x3D; point[1];</span><br><span class="line">                        &#x2F;&#x2F; 搜索该陆地四周</span><br><span class="line">                        for(int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 四周新的横坐标</span><br><span class="line">                            int tx &#x3D; x + dx[k];</span><br><span class="line">                            &#x2F;&#x2F; 四周新的纵坐标</span><br><span class="line">                            int ty &#x3D; y + dy[k];</span><br><span class="line">                            &#x2F;&#x2F; 不越界并且为陆地则入队</span><br><span class="line">                            if(tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; grid[tx][ty] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                                queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                                &#x2F;&#x2F; 访问过则置为&#39;0&#39;</span><br><span class="line">                                grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420100042839.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>将陆地视为无向图，相邻的1之前视为边，每次对四周进行dfs搜索，岛屿的数量即是dfs搜索的次数</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(char[][] grid, int tx, int ty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        &#x2F;&#x2F; 越界或者已访问跳出递归</span><br><span class="line">        if(tx &lt; 0 || tx &gt;&#x3D; m || ty &lt; 0 || ty &gt;&#x3D; n || grid[tx][ty] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 访问过注意置&#39;0&#39;</span><br><span class="line">        grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F; 上</span><br><span class="line">        dfs(grid, tx + 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 下</span><br><span class="line">        dfs(grid, tx - 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 左</span><br><span class="line">        dfs(grid, tx, ty - 1);</span><br><span class="line">        &#x2F;&#x2F; 右</span><br><span class="line">        dfs(grid, tx, ty + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420103029306.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/number-of-islands&lt;/a&gt; 】&lt;br&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;11110&lt;br&gt;11010&lt;br&gt;11000&lt;br&gt;00000&lt;br&gt;输出: 1&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;11000&lt;br&gt;11000&lt;br&gt;00100&lt;br&gt;00011&lt;br&gt;输出: 3&lt;br&gt;解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-19T03:02:16.000Z</published>
    <updated>2020-04-19T03:14:11.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a> 】<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>图中可以很直观看到需要求解最大的矩形面积，只要找到所有情况用底乘两端较小的高再求最大值即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 直接暴力查找所有情况</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419111107235.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>问题的关键在于当底不断缩小时，如果要使面积变大，只能尽可能取到更大的高，那么初始底最大，从两端慢慢找到一个高更大的（即两端小的那端移动来找更大的高）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        &#x2F;&#x2F; 头</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 尾</span><br><span class="line">        int j &#x3D; height.length - 1;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            &#x2F;&#x2F; 算出围成矩形的最大面积</span><br><span class="line">            maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#x2F;&#x2F; 移动较小尽量确保高更大</span><br><span class="line">            if(height[i] &lt;&#x3D; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110353562.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water&lt;/a&gt; 】&lt;br&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png&quot; alt&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;br&gt;输出：49&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-17T06:38:05.000Z</published>
    <updated>2020-04-17T08:07:43.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a> 】<br>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>我一开始的思路不是超时就是用例通过率只有70%。。。<br>所以参照了贪心算法的几种思路，有几个关键：<br>（1）如果考虑某个位置可达？只要最大跳跃长度不小于最后一个位置即可，即i + nums[i] &gt;= nums.length - 1<br>（2）从左往右开始判断还是从右往左判断？分别怎样处理？</strong></p><h1 id="三种方案"><a href="#三种方案" class="headerlink" title="三种方案"></a>三种方案</h1><p><strong>从右往左遍历最近的可达则舍去最后一个</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当前位置距离最后一个可达的最小长度</span><br><span class="line">    int curMin &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二个开始往左遍历判断是否可达最后一个</span><br><span class="line">    for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前位置可达，视为舍弃最后一个</span><br><span class="line">        if (nums[i] &gt;&#x3D; curMin) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意置一</span><br><span class="line">            curMin &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; 不可达代表当前位置左边一个位置距离最后一个可达的最小长度变长一单位</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curMin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 为一代表每次判断都可达</span><br><span class="line">    return curMin &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417035810776.png" alt></p><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2><p><strong>从左往右只要下一个位置可达每次更新最大跳跃距离， 只要有任意一个位置可达则代表可达，遍历完代表不可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 目前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 从头遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 下一个位置可跳跃达到，更新当前最大跳跃距离</span><br><span class="line">            if (i &lt;&#x3D; curMax) &#123;</span><br><span class="line">                curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">                &#x2F;&#x2F; 如果可以当前可跳跃最大距离大于最后的位置即可跳跃到达</span><br><span class="line">                if (i + nums[i] &gt;&#x3D; n - 1) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040013206.png" alt></p><h2 id="方案III"><a href="#方案III" class="headerlink" title="方案III"></a>方案III</h2><p><strong>从左往右跳跃，每次也是更新最大跳跃距离，不过同II不同的是，不可达的判断是最大跳跃距离位置左边都是可跳跃区域，右边跳不到，遍历完代表可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从左往右跳的话，最大跳跃距离位置左边都是可跳跃区域，右边跳不到</span><br><span class="line">            if(i &gt; curMax) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 更新最大跳跃距离</span><br><span class="line">            curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040224491.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/jump-game&lt;/a&gt; 】&lt;br&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [2,3,1,1,4]&lt;br&gt;输出: true&lt;br&gt;解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [3,2,1,0,4]&lt;br&gt;输出: false&lt;br&gt;解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>01矩阵</title>
    <link href="https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/"/>
    <id>https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-15T06:22:12.000Z</published>
    <updated>2020-04-15T06:42:27.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/01-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/01-matrix</a> 】</p><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p><p>示例 1:<br>输入:<br>0 0 0<br>0 1 0<br>0 0 0<br>输出:<br>0 0 0<br>0 1 0<br>0 0 0</p><p>示例 2:<br>输入:<br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br>0 0 0<br>0 1 0<br>1 2 1</p><p>注意:<br>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>需要搜索邻近方向可以考虑用bfs搜索来解决，这里0、1都是不定的，按照多源bfs的一般思路来<br>有几个关键问题：<br>（1）队列里面先放什么？入队条件是什么？一开始尝试先将所有的1入队，然后向四周找到一个最近的0去计算距离，不过这样很难处理最近距离以及考虑入队条件，后来考虑将所有0先入队，设置该位置已经访问过，那么问题一下子迎刃而解<br>（2）最近距离如何计算？向四周查找时目标位置的距离每次都是初始距离 + 1，特别注意越界问题以及访问过的位置不要重复累加和入队</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列存放为0的元素当前横坐标、纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Queue&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;-1, 1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int[][] updateMatrix(int[][] matrix) &#123;</span><br><span class="line">        int m &#x3D; matrix.length;</span><br><span class="line">        int n &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int[][] res &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 每个结点是否访问</span><br><span class="line">        boolean[][] used &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 将所有0入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] point &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 横坐标</span><br><span class="line">            int x &#x3D; point[0];</span><br><span class="line">            &#x2F;&#x2F; 纵坐标</span><br><span class="line">            int y &#x3D; point[1];</span><br><span class="line">            for (int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向横坐标</span><br><span class="line">                int tx &#x3D; x + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向纵坐标</span><br><span class="line">                int ty &#x3D; y + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界或者已经被访问则跳过, 否则累加计算计算距离0最近的距离</span><br><span class="line">                if (tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; !used[tx][ty]) &#123;</span><br><span class="line">                    res[tx][ty] &#x3D; res[x][y] + 1;</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[tx][ty] &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 继续找其他1</span><br><span class="line">                    queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/15/01%E7%9F%A9%E9%98%B5/20200415024226920.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/01-matrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/01-matrix&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;br&gt;两个相邻元素间的距离为 1 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 1 1&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 2 1&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;给定矩阵的元素个数不超过 10000。&lt;br&gt;给定矩阵中至少有一个元素是 0。&lt;br&gt;矩阵中的元素只在四个方向上相邻: 上、下、左、右。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>两数相加II</title>
    <link href="https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-04-14T06:02:23.000Z</published>
    <updated>2020-04-14T06:57:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a> 】<br>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：<br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：<br>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>平常计算两数和时都是在低位开始算起，满十进一即可，只是要注意单链表遍历的顺序跟结果是相反的，自然而然可以想到使用栈来进行逆序<br>利用三个栈，两个存放两个链表，另一个存放结果，最终逆序输出即可，几个关键<br>（1）如果两数长度不等需高位补零计算<br>（2）特别注意栈空后进制剩余仍需再计算一次</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l1 + l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack3 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 最终结果</span><br><span class="line">        ListNode res &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 最终结果的头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 值为的0结点</span><br><span class="line">        ListNode n0 &#x3D; new ListNode(0);</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while((!stack1.isEmpty()) || (!stack2.isEmpty()) || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不对齐的补零</span><br><span class="line">            if(stack1.isEmpty()) &#123;</span><br><span class="line">                stack1.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack2.isEmpty()) &#123;</span><br><span class="line">                stack2.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 加法</span><br><span class="line">            x &#x3D; (stack1.pop().val + stack2.pop().val);</span><br><span class="line">            &#x2F;&#x2F; 低位是否有进位</span><br><span class="line">            if(k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                x++;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前无进位</span><br><span class="line">            if(x &lt; 10) &#123;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 当前有进位</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                x %&#x3D; 10;</span><br><span class="line">                k &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            stack3.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 反向取出栈的结果即可</span><br><span class="line">        if(!stack3.isEmpty()) &#123;</span><br><span class="line">            head &#x3D; stack3.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意存放结果</span><br><span class="line">        res &#x3D; head;</span><br><span class="line">        while(!stack3.isEmpty()) &#123;</span><br><span class="line">            ListNode top &#x3D; stack3.pop();</span><br><span class="line">            head.next &#x3D; top;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 单链表</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414021233262.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>在栈里存放直接存放结点处理太耗时耗力，直接存放待加的值即可<br>边加边使用头插法刚好可以实现逆序，类似栈的效果，不用额外设置第三个栈来辅助判断</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 结果头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty() || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int a &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">            int b &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">            &#x2F;&#x2F; 求和、注意加上低位的进位</span><br><span class="line">            x &#x3D; a + b + k;</span><br><span class="line">            &#x2F;&#x2F; 求进制</span><br><span class="line">            k &#x3D; x &#x2F; 10;</span><br><span class="line">            &#x2F;&#x2F; 求本位</span><br><span class="line">            x %&#x3D; 10;</span><br><span class="line">            &#x2F;&#x2F; 头插法：新结点每次都插入到链表头部，刚好实现逆序</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414024711242.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p><strong>虽然一开始的思路还算比较清晰，但是由于太久没使用链表，有些地方结果还是调试了很久。。。所以还是要多加练习</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers-ii&lt;/a&gt; 】&lt;br&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;进阶：&lt;br&gt;如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：(7 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br&gt;输出：7 -&amp;gt; 8 -&amp;gt; 0 -&amp;gt; 7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
