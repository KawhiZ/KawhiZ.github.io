<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kawhiz.github.io/"/>
  <updated>2020-04-24T04:40:53.420Z</updated>
  <id>https://kawhiz.github.io/</id>
  
  <author>
    <name>庄健彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-04-24T04:22:11.000Z</published>
    <updated>2020-04-24T04:40:53.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a> 】<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:<br>输入: [7,5,6,4]<br>输出: 5</p><p>限制：<br>0 &lt;= 数组长度 &lt;= 50000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始直接暴力破解，果不其然超时,后来还是参考了官方题解归并排序的思想，主要有几个关键问题：<br>（1）归并排序为什么就能够在O（nlogn）时间内统计逆序对数目？如果右子数组比左子数组大，那么逆序对就是当前左子数组所有数的和（注意左右子数组都是有序的前提下），以【7，5，6，4】为例，当回溯到【5，7】，【4，6】时5和4比较，4小所以当前含有【5，4】，【7，4】两个逆序对（左子数组的长度）；<br>（2）归并排序中递归分治的出口是什么？很明显就是只有一个元素则必定有序<br>（3）注意当left、right很大时，二分取（left + right） / 2 可能会溢出，所以用int mid = left + (right - left) / 2代替</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reversePairs(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 如果只有0、1个数，则不存在逆序对</span><br><span class="line">        if(n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 临时数组</span><br><span class="line">        int[] temp &#x3D; new int[n];</span><br><span class="line">        return reversePairs(0, n - 1, nums, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    public int reversePairs(int left, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 子数组只有一个必定有序</span><br><span class="line">        if (left &#x3D;&#x3D; right) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 逆序对</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意（left + right） &#x2F; 2 可能会溢出</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 左右两边逆序对数目</span><br><span class="line">        int leftCount &#x3D; reversePairs(left, mid, nums, temp);</span><br><span class="line">        int rightCount &#x3D; reversePairs(mid + 1, right, nums, temp);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 横跨左右逆序对数目</span><br><span class="line">        int crossCount &#x3D; mergeSort(left, mid, right, nums, temp);</span><br><span class="line">        return leftCount + rightCount + crossCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 归并回原数组</span><br><span class="line">     * @param left</span><br><span class="line">     * @param mid</span><br><span class="line">     * @param right</span><br><span class="line">     * @param nums</span><br><span class="line">     * @param temp</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int mergeSort(int left, int mid, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先保存在临时数组</span><br><span class="line">        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 左子数组第一个</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        &#x2F;&#x2F; 右子数组第一个</span><br><span class="line">        int j &#x3D; mid + 1;</span><br><span class="line"></span><br><span class="line">        for (int k &#x3D; left; k &lt;&#x3D; right; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果左边合并结束，只能合并右边</span><br><span class="line">            if (i &#x3D;&#x3D; mid + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 如果右边合并结束，只能合并左边</span><br><span class="line">            &#125; else if (j &#x3D;&#x3D; right + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 如果左边的小则代表不存在逆序对，直接合并</span><br><span class="line">            &#125; else if (temp[i] &lt;&#x3D; temp[j]) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 否则计算逆序对</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 计算的关键代码</span><br><span class="line">                count +&#x3D; (mid - i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/20200424122857899.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&lt;/a&gt; 】&lt;br&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;0 &amp;lt;= 数组长度 &amp;lt;= 50000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-04-20T01:57:56.000Z</published>
    <updated>2020-04-20T02:30:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a> 】<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:<br>输入:<br>11110<br>11010<br>11000<br>00000<br>输出: 1</p><p>示例 2:<br>输入:<br>11000<br>11000<br>00100<br>00011<br>输出: 3<br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>比较经典的题目，仍然采用bfs的一般思路，遍历二维数组，找到一个陆地入队，设置已访问，对陆地周围进行搜索，符合条件入队，再设置已访问，有几个注意的点<br>（1）注意初始二维数组类型是char而不是int<br>（2）注意每次搜索完必须设置已访问，这里可以直接将访问过位置设置为’0’或者其他标记均可（设置成零的话执行是最快的），这里无需额外开一个数组记录<br>（3）注意岛屿的数目即是bfs搜索的次数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 岛屿数加一</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    &#x2F;&#x2F; 陆地入队</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 陆地访问过则置为&#39;0&#39;</span><br><span class="line">                    grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">                    while(!queue.isEmpty()) &#123;</span><br><span class="line">                        int[] point &#x3D; queue.poll();</span><br><span class="line">                        &#x2F;&#x2F; 当前横坐标</span><br><span class="line">                        int x &#x3D; point[0];</span><br><span class="line">                        &#x2F;&#x2F; 当前纵坐标</span><br><span class="line">                        int y &#x3D; point[1];</span><br><span class="line">                        &#x2F;&#x2F; 搜索该陆地四周</span><br><span class="line">                        for(int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 四周新的横坐标</span><br><span class="line">                            int tx &#x3D; x + dx[k];</span><br><span class="line">                            &#x2F;&#x2F; 四周新的纵坐标</span><br><span class="line">                            int ty &#x3D; y + dy[k];</span><br><span class="line">                            &#x2F;&#x2F; 不越界并且为陆地则入队</span><br><span class="line">                            if(tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; grid[tx][ty] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                                queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                                &#x2F;&#x2F; 访问过则置为&#39;0&#39;</span><br><span class="line">                                grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420100042839.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>将陆地视为无向图，相邻的1之前视为边，每次对四周进行dfs搜索，岛屿的数量即是dfs搜索的次数</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(char[][] grid, int tx, int ty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        &#x2F;&#x2F; 越界或者已访问跳出递归</span><br><span class="line">        if(tx &lt; 0 || tx &gt;&#x3D; m || ty &lt; 0 || ty &gt;&#x3D; n || grid[tx][ty] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 访问过注意置&#39;0&#39;</span><br><span class="line">        grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F; 上</span><br><span class="line">        dfs(grid, tx + 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 下</span><br><span class="line">        dfs(grid, tx - 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 左</span><br><span class="line">        dfs(grid, tx, ty - 1);</span><br><span class="line">        &#x2F;&#x2F; 右</span><br><span class="line">        dfs(grid, tx, ty + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420103029306.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/number-of-islands&lt;/a&gt; 】&lt;br&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;11110&lt;br&gt;11010&lt;br&gt;11000&lt;br&gt;00000&lt;br&gt;输出: 1&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;11000&lt;br&gt;11000&lt;br&gt;00100&lt;br&gt;00011&lt;br&gt;输出: 3&lt;br&gt;解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-19T03:02:16.000Z</published>
    <updated>2020-04-19T03:14:11.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a> 】<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>图中可以很直观看到需要求解最大的矩形面积，只要找到所有情况用底乘两端较小的高再求最大值即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 直接暴力查找所有情况</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419111107235.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>问题的关键在于当底不断缩小时，如果要使面积变大，只能尽可能取到更大的高，那么初始底最大，从两端慢慢找到一个高更大的（即两端小的那端移动来找更大的高）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        &#x2F;&#x2F; 头</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 尾</span><br><span class="line">        int j &#x3D; height.length - 1;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            &#x2F;&#x2F; 算出围成矩形的最大面积</span><br><span class="line">            maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#x2F;&#x2F; 移动较小尽量确保高更大</span><br><span class="line">            if(height[i] &lt;&#x3D; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110353562.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water&lt;/a&gt; 】&lt;br&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png&quot; alt&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;br&gt;输出：49&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-17T06:38:05.000Z</published>
    <updated>2020-04-17T08:07:43.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a> 】<br>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>我一开始的思路不是超时就是用例通过率只有70%。。。<br>所以参照了贪心算法的几种思路，有几个关键：<br>（1）如果考虑某个位置可达？只要最大跳跃长度不小于最后一个位置即可，即i + nums[i] &gt;= nums.length - 1<br>（2）从左往右开始判断还是从右往左判断？分别怎样处理？</strong></p><h1 id="三种方案"><a href="#三种方案" class="headerlink" title="三种方案"></a>三种方案</h1><p><strong>从右往左遍历最近的可达则舍去最后一个</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当前位置距离最后一个可达的最小长度</span><br><span class="line">    int curMin &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二个开始往左遍历判断是否可达最后一个</span><br><span class="line">    for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前位置可达，视为舍弃最后一个</span><br><span class="line">        if (nums[i] &gt;&#x3D; curMin) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意置一</span><br><span class="line">            curMin &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; 不可达代表当前位置左边一个位置距离最后一个可达的最小长度变长一单位</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curMin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 为一代表每次判断都可达</span><br><span class="line">    return curMin &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417035810776.png" alt></p><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2><p><strong>从左往右只要下一个位置可达每次更新最大跳跃距离， 只要有任意一个位置可达则代表可达，遍历完代表不可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 目前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 从头遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 下一个位置可跳跃达到，更新当前最大跳跃距离</span><br><span class="line">            if (i &lt;&#x3D; curMax) &#123;</span><br><span class="line">                curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">                &#x2F;&#x2F; 如果可以当前可跳跃最大距离大于最后的位置即可跳跃到达</span><br><span class="line">                if (i + nums[i] &gt;&#x3D; n - 1) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040013206.png" alt></p><h2 id="方案III"><a href="#方案III" class="headerlink" title="方案III"></a>方案III</h2><p><strong>从左往右跳跃，每次也是更新最大跳跃距离，不过同II不同的是，不可达的判断是最大跳跃距离位置左边都是可跳跃区域，右边跳不到，遍历完代表可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从左往右跳的话，最大跳跃距离位置左边都是可跳跃区域，右边跳不到</span><br><span class="line">            if(i &gt; curMax) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 更新最大跳跃距离</span><br><span class="line">            curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040224491.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/jump-game&lt;/a&gt; 】&lt;br&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [2,3,1,1,4]&lt;br&gt;输出: true&lt;br&gt;解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [3,2,1,0,4]&lt;br&gt;输出: false&lt;br&gt;解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>01矩阵</title>
    <link href="https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/"/>
    <id>https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-15T06:22:12.000Z</published>
    <updated>2020-04-15T06:42:27.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/01-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/01-matrix</a> 】</p><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p><p>示例 1:<br>输入:<br>0 0 0<br>0 1 0<br>0 0 0<br>输出:<br>0 0 0<br>0 1 0<br>0 0 0</p><p>示例 2:<br>输入:<br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br>0 0 0<br>0 1 0<br>1 2 1</p><p>注意:<br>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>需要搜索邻近方向可以考虑用bfs搜索来解决，这里0、1都是不定的，按照多源bfs的一般思路来<br>有几个关键问题：<br>（1）队列里面先放什么？入队条件是什么？一开始尝试先将所有的1入队，然后向四周找到一个最近的0去计算距离，不过这样很难处理最近距离以及考虑入队条件，后来考虑将所有0先入队，设置该位置已经访问过，那么问题一下子迎刃而解<br>（2）最近距离如何计算？向四周查找时目标位置的距离每次都是初始距离 + 1，特别注意越界问题以及访问过的位置不要重复累加和入队</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列存放为0的元素当前横坐标、纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Queue&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;-1, 1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int[][] updateMatrix(int[][] matrix) &#123;</span><br><span class="line">        int m &#x3D; matrix.length;</span><br><span class="line">        int n &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int[][] res &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 每个结点是否访问</span><br><span class="line">        boolean[][] used &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 将所有0入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] point &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 横坐标</span><br><span class="line">            int x &#x3D; point[0];</span><br><span class="line">            &#x2F;&#x2F; 纵坐标</span><br><span class="line">            int y &#x3D; point[1];</span><br><span class="line">            for (int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向横坐标</span><br><span class="line">                int tx &#x3D; x + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向纵坐标</span><br><span class="line">                int ty &#x3D; y + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界或者已经被访问则跳过, 否则累加计算计算距离0最近的距离</span><br><span class="line">                if (tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; !used[tx][ty]) &#123;</span><br><span class="line">                    res[tx][ty] &#x3D; res[x][y] + 1;</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[tx][ty] &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 继续找其他1</span><br><span class="line">                    queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/15/01%E7%9F%A9%E9%98%B5/20200415024226920.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/01-matrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/01-matrix&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;br&gt;两个相邻元素间的距离为 1 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 1 1&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 2 1&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;给定矩阵的元素个数不超过 10000。&lt;br&gt;给定矩阵中至少有一个元素是 0。&lt;br&gt;矩阵中的元素只在四个方向上相邻: 上、下、左、右。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>两数相加II</title>
    <link href="https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-04-14T06:02:23.000Z</published>
    <updated>2020-04-14T06:57:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a> 】<br>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：<br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：<br>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>平常计算两数和时都是在低位开始算起，满十进一即可，只是要注意单链表遍历的顺序跟结果是相反的，自然而然可以想到使用栈来进行逆序<br>利用三个栈，两个存放两个链表，另一个存放结果，最终逆序输出即可，几个关键<br>（1）如果两数长度不等需高位补零计算<br>（2）特别注意栈空后进制剩余仍需再计算一次</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l1 + l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack3 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 最终结果</span><br><span class="line">        ListNode res &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 最终结果的头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 值为的0结点</span><br><span class="line">        ListNode n0 &#x3D; new ListNode(0);</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while((!stack1.isEmpty()) || (!stack2.isEmpty()) || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不对齐的补零</span><br><span class="line">            if(stack1.isEmpty()) &#123;</span><br><span class="line">                stack1.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack2.isEmpty()) &#123;</span><br><span class="line">                stack2.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 加法</span><br><span class="line">            x &#x3D; (stack1.pop().val + stack2.pop().val);</span><br><span class="line">            &#x2F;&#x2F; 低位是否有进位</span><br><span class="line">            if(k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                x++;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前无进位</span><br><span class="line">            if(x &lt; 10) &#123;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 当前有进位</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                x %&#x3D; 10;</span><br><span class="line">                k &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            stack3.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 反向取出栈的结果即可</span><br><span class="line">        if(!stack3.isEmpty()) &#123;</span><br><span class="line">            head &#x3D; stack3.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意存放结果</span><br><span class="line">        res &#x3D; head;</span><br><span class="line">        while(!stack3.isEmpty()) &#123;</span><br><span class="line">            ListNode top &#x3D; stack3.pop();</span><br><span class="line">            head.next &#x3D; top;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 单链表</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414021233262.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>在栈里存放直接存放结点处理太耗时耗力，直接存放待加的值即可<br>边加边使用头插法刚好可以实现逆序，类似栈的效果，不用额外设置第三个栈来辅助判断</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 结果头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty() || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int a &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">            int b &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">            &#x2F;&#x2F; 求和、注意加上低位的进位</span><br><span class="line">            x &#x3D; a + b + k;</span><br><span class="line">            &#x2F;&#x2F; 求进制</span><br><span class="line">            k &#x3D; x &#x2F; 10;</span><br><span class="line">            &#x2F;&#x2F; 求本位</span><br><span class="line">            x %&#x3D; 10;</span><br><span class="line">            &#x2F;&#x2F; 头插法：新结点每次都插入到链表头部，刚好实现逆序</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414024711242.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p><strong>虽然一开始的思路还算比较清晰，但是由于太久没使用链表，有些地方结果还是调试了很久。。。所以还是要多加练习</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers-ii&lt;/a&gt; 】&lt;br&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;进阶：&lt;br&gt;如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：(7 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br&gt;输出：7 -&amp;gt; 8 -&amp;gt; 0 -&amp;gt; 7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实现Trie前缀树</title>
    <link href="https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/</id>
    <published>2020-04-13T04:05:11.000Z</published>
    <updated>2020-04-13T07:09:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a> 】<br>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true</p><p>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始的思路是用一个LinkedList存放，插入和查询都已实现，直接暴力查找每一个前缀子串是否匹配，缺点显而易见、如果单词非常长非常多，那么每次都要重复大量判断前缀，case通过率93%，最后一个用例超时<br>所以如果能把前缀都存储下来，每次就不需要大量重复判断，因为只有26个小写字母，所以可以使用前缀树（字典树）来存储，有以下几个关键<br>（1）每个前缀树最多有26个分支，每次拼写完一个单词需要标记拼写结束<br>（2）插入时没有后一个结点则需要新创建一个，否则继续往下一层查找<br>（3）查找前缀和查找单词区别在于是否标记单词拼写结束</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树（字典树）长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final int length &#x3D; 26;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树下个结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Trie[] next;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 单词拼写是否结束</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        next &#x3D; new Trie[length];</span><br><span class="line">        isEnd &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在前缀树中插入一个单词</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前结点下一个结点为空，则创建新的前缀树</span><br><span class="line">            if (node.next[c - &#39;a&#39;] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                node.next[c - &#39;a&#39;] &#x3D; new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 继续下一个结点判断</span><br><span class="line">            node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 每次插入完一个单词记得标记</span><br><span class="line">        node.isEnd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词前缀</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Trie searchPrefix(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到下个结点则继续找</span><br><span class="line">            if (node.next[c - &#39;a&#39;] !&#x3D; null) &#123;</span><br><span class="line">                node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">                &#x2F;&#x2F; 否则直接返回null</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(word);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到且必须为完整单词则代表找到该单词</span><br><span class="line">        return node !&#x3D; null &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找前缀是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(prefix);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到前缀则返回true</span><br><span class="line">        return node !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/20200413121411842.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree&lt;/a&gt; 】&lt;br&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;Trie trie = new Trie();&lt;br&gt;trie.insert(“apple”);&lt;br&gt;trie.search(“apple”);   // 返回 true&lt;br&gt;trie.search(“app”);     // 返回 false&lt;br&gt;trie.startsWith(“app”); // 返回 true&lt;br&gt;trie.insert(“app”);&lt;br&gt;trie.search(“app”);     // 返回 true&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;br&gt;保证所有输入均为非空字符串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>分割等和子集</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2020-04-12T10:48:41.000Z</published>
    <updated>2020-04-12T11:12:20.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a> 】<br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><p>示例 1:<br>输入: [1, 5, 11, 5]</p><p>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:<br>输入: [1, 2, 3, 5]</p><p>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>这题一开始在思考如何解决还是有点棘手，怎么都没想到这是一道背包问题的变种。。。。。。<br>按照背包问题的一般思路来，这里的数类似重量，这里需要等分数组，所以数组和的一半类似总价值<br>状态dp(i,j)代表前i个数当前和j是否可等分，这里主要有加不加上第i个数两种情况<br>(1)不加上第i个数：dp(i, j) = dp(i - 1)(j)<br>(2)加上第i个数：dp(i, j) = dp(i - 1)(j - nums(i))<br>所以状态转移式dp(i, j) = (1) || (2)<br>注意考虑边界如果当前和刚好为第i个数，j = nums[i]刚好分割，那么dp(i, j)为true<br>以nums={1, 3, 4, 2}为例，具体过程如图</strong><br><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412071203200.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int m &#x3D; nums.length;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 求数组和</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            n +&#x3D; num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 数组和不为偶数或者只有一个数则无法等分</span><br><span class="line">        if(n % 2 !&#x3D; 0 || m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意列数是数组和的一半加一，包括零的情况</span><br><span class="line">        n &#x3D; (n &gt;&gt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F; dp[i][j] 代表前i个数以及这些数的和刚好为j</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 只有一个数的情况</span><br><span class="line">        if(nums[0] &lt;&#x3D; n - 1) &#123;</span><br><span class="line">            dp[0][nums[0]] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        int i, j;</span><br><span class="line">        &#x2F;&#x2F; 从第二个数开始遍历</span><br><span class="line">        for (i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不选的情况</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">                &#x2F;&#x2F; 刚好可以等分的情况</span><br><span class="line">                if(j &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 分割后还有剩余的情况</span><br><span class="line">                if(j &gt; nums[i]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 问题的关键、状态转移式</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j] || dp[i - 1][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 只要最后一列有一个值为真直接返回true即可</span><br><span class="line">            if(dp[i][j - 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412065612121.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equal-subset-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/partition-equal-subset-sum&lt;/a&gt; 】&lt;br&gt;给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;每个数组中的元素不会超过 100&lt;br&gt;数组的大小不会超过 200&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [1, 5, 11, 5]&lt;/p&gt;
&lt;p&gt;输出: true&lt;br&gt;解释: 数组可以分割成 [1, 5, 5] 和 [11].&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [1, 2, 3, 5]&lt;/p&gt;
&lt;p&gt;输出: false&lt;br&gt;解释: 数组不能分割成两个元素和相等的子集.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>自定义字符串排序</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T06:37:56.000Z</published>
    <updated>2020-04-12T07:30:56.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/custom-sort-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/custom-sort-string</a> 】</p><p>字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。<br>S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。<br>返回任意一种符合条件的字符串T。</p><p>示例:<br>输入:<br>S = “cba”<br>T = “abcd”<br>输出: “cbad”<br>解释:<br>S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.<br>由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。</p><p>注意:<br>S的最大长度为26，其中没有重复的字符。<br>T的最大长度为200。<br>S和T只包含小写字符。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>既然要按照S中的字符相对顺序对T进行排序，一种直观的思路就是遍历S然后每次都遍历T，找到一个相等的则记录下来，同时记录T中该字符是否已使用，最后将T中未使用的直接加入到结果后面即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 记录T中每个字符是否使用过</span><br><span class="line">        boolean[] used &#x3D; new boolean[T.length()];</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(int i &#x3D; 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历T</span><br><span class="line">            for(int j &#x3D; 0; j &lt; T.length(); j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在T中找到一个跟S相等的则拼接起来</span><br><span class="line">                if(S.charAt(i) &#x3D;&#x3D; T.charAt(j)) &#123;</span><br><span class="line">                    sb.append(T.charAt(j));</span><br><span class="line">                    &#x2F;&#x2F; 记录已拼接</span><br><span class="line">                    used[j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res &#x3D; sb.toString();</span><br><span class="line">        &#x2F;&#x2F; 长度相等代表T中全部字符已拼接</span><br><span class="line">        if(res.length() &#x3D;&#x3D; T.length()) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 否则拼接未拼接的</span><br><span class="line">        for(int i &#x3D; 0; i &lt; used.length; i++) &#123;</span><br><span class="line">            if(!used[i]) &#123;</span><br><span class="line">                sb.append(T.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412024720133.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>前面做法每次遍历T时都要执行charAt去判断T和S的字符串是否相等，及其耗时，同时如果T的长度非常长的话，used数组也会非常占用空间，最后补充记录S中无关的字符也会非常耗时<br>因为只有26个小写字符直接使用长度26的一维数组countT记录T中每个字母出现的次数，遍历S同时将counT中出现次数不为零的字母加上，最后注意加上S中没有的字母即可</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        &#x2F;&#x2F; 自定义排序后的结果</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 存放T中&#39;a&#39; ~ &#39;z&#39;出现的次数</span><br><span class="line">        int[] countT &#x3D; new int[26];</span><br><span class="line">        &#x2F;&#x2F; 统计T中每个小写字母出现得到次数</span><br><span class="line">        for(char c : T.toCharArray()) &#123;</span><br><span class="line">            countT[c - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(char c : S.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历countT，注意判断条件i &lt; countT[c - &#39;a&#39;]写法，T中有多少个S出现的字符就添加多少次</span><br><span class="line">            for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意清零不影响后面其他S中没有的字符添加</span><br><span class="line">            countT[c - &#39;a&#39;] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 加上T剩余的原先S中没有的字母</span><br><span class="line">        for(char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;</span><br><span class="line">           for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">               res.append(c);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412032101885.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/custom-sort-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/custom-sort-string&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。&lt;br&gt;S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。&lt;br&gt;返回任意一种符合条件的字符串T。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入:&lt;br&gt;S = “cba”&lt;br&gt;T = “abcd”&lt;br&gt;输出: “cbad”&lt;br&gt;解释:&lt;br&gt;S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.&lt;br&gt;由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;S的最大长度为26，其中没有重复的字符。&lt;br&gt;T的最大长度为200。&lt;br&gt;S和T只包含小写字符。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>翻转字符串里的单词</title>
    <link href="https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2020-04-10T02:54:46.000Z</published>
    <updated>2020-04-10T03:57:07.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string</a> 】<br>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：<br>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除首位无关空格，再按空白分割成字符串数组，重新反转拼接回去<br>稍微注意java中split(“\s+”)的写法，需要加上转义字符，s+代表匹配包括空格、制表健等空白部分</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 按中间空白部分（包括空格制表键等）分割成String数组</span><br><span class="line">        String[] strArr &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        for(int i &#x3D; strArr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            sb.append(strArr[i]);</span><br><span class="line">            &#x2F;&#x2F; 统一中间加一个空格分割</span><br><span class="line">            if(i &gt; 0) &#123;</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410105915195.png" alt><br><strong>API简洁版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 通过空白部分分割</span><br><span class="line">        List&lt;String&gt; wordList &#x3D; Arrays.asList(s.split(&quot;\\s+&quot;));</span><br><span class="line">        &#x2F;&#x2F; 反转</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        &#x2F;&#x2F; 重新以单空格拼接回去</span><br><span class="line">        return String.join(&quot; &quot;, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410111721079.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>尽量少使用一些API来提升速度<br>问题的关键在于需要反转同时需要找到不定数目空格分割的单词<br>从字符串尾开始遍历实现反转，设置双指针分别用来记录每个单词的首尾，找到一个则拼接原字符串的子串到结果集里，注意中间统一按一个空格分割</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; i用来记录单词的首字符下标</span><br><span class="line">        int i &#x3D; s.length() - 1;</span><br><span class="line">        &#x2F;&#x2F; j用来记录单词的末字符下标</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 从原字符串尾部开始遍历整个字符串实现反转</span><br><span class="line">        while(i &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到最后一个单词第一个空格分割符</span><br><span class="line">            while(i &gt;&#x3D;0 &amp;&amp; s.charAt(i) !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意substring方法的下标和写法、记得去除最后一个多余的空格</span><br><span class="line">            if(i &gt;&#x3D; 0) &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1) + &quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 找到倒数第二个单词最后一个字符</span><br><span class="line">            while(i &gt;&#x3D; 0 &amp;&amp; s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加完重新更新</span><br><span class="line">            j &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410115331506.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/reverse-words-in-a-string&lt;/a&gt; 】&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入: “the sky is blue”&lt;br&gt;输出: “blue is sky the”&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入: “  hello world!  “&lt;br&gt;输出: “world! hello”&lt;br&gt;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入: “a good   example”&lt;br&gt;输出: “example good a”&lt;br&gt;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;无空格字符构成一个单词。&lt;br&gt;输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;br&gt;如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>括号生成</title>
    <link href="https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2020-04-09T03:33:19.000Z</published>
    <updated>2020-04-09T04:30:18.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a> 】<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>因为是要生成所有可能的有效括号，类似全排列，自然而然想到用dfs递归搜索<br>n对括号的话，从根节点空字符串开始，一直到搜索到深度2n则记录其中一种情况<br>这里递归参数设为左右括号剩余量，以及当前字符串，递归条件通过有效括号匹配规则剪枝、递归出口就是当左右括号都没有剩余<br><em>问题的关键在于分析以下几种情况</em><br>左右括号都没有剩余，则到底，记录其中一种有效结果<br>左子树生成前提是左括号有剩余<br>右子树生成前提是右括号有剩余，并且要左括号剩余比右括号少才会匹配成功</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回空</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; dfs搜索根结点为&quot;&quot;</span><br><span class="line">        dfs(n, n, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; left代表剩余左括号数目，right代表剩余右括号数目，String每次都创建一个新对象回溯时不需要恢复现场</span><br><span class="line">    public void dfs(int left, int right, String curStr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左右括号都不剩余代表深度到底，加入结果集</span><br><span class="line">        if(left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左括号剩余则生成左枝</span><br><span class="line">        if(left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr + &quot;(&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右括号剩余，且左括号剩余数目必须小于右括号才有可能匹配有效</span><br><span class="line">        if(right &gt; 0 &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/20200409120632596.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/generate-parentheses&lt;/a&gt; 】&lt;br&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：n = 3&lt;br&gt;输出：[&lt;br&gt;       “((()))”,&lt;br&gt;       “(()())”,&lt;br&gt;       “(())()”,&lt;br&gt;       “()(())”,&lt;br&gt;       “()()()”&lt;br&gt;     ]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://kawhiz.github.io/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://kawhiz.github.io/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2020-04-08T05:24:50.000Z</published>
    <updated>2020-04-08T05:52:03.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a> 】<br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：<br>输入：m = 2, n = 3, k = 1<br>输出：3</p><p>示例 2：</p><p>输入：m = 3, n = 1, k = 0<br>输出：1<br>提示：</p><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>bfs搜索的常规思想<br>设置方向数组来进行新下标计算，注意越界问题<br>注意这里下标范围是百位数以内的，直接求数位和判断下标是否可达，设置数组记录结点是否访问，未访问可达则入队</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列存放访问结点的横纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    LinkedList&lt;int[]&gt; queue;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放横坐标变化常量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放纵坐标变化常量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录结点是否访问过</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean[][] used;</span><br><span class="line"></span><br><span class="line">    public int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可达格子数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        used &#x3D; new boolean[m][n];</span><br><span class="line">        queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 先判断(0, 0)是否满足数位和不大于k</span><br><span class="line">        if (k &gt;&#x3D; 0) &#123;</span><br><span class="line">            queue.offer(new int[]&#123;0, 0&#125;);</span><br><span class="line">            used[0][0] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前结点</span><br><span class="line">            int[] curNode &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 横坐标</span><br><span class="line">            int x &#x3D; curNode[0];</span><br><span class="line">            &#x2F;&#x2F; 纵坐标</span><br><span class="line">            int y &#x3D; curNode[1];</span><br><span class="line">            boolean flag &#x3D; (sum(x) + sum(y) &lt;&#x3D; k);</span><br><span class="line">            &#x2F;&#x2F; 如果当前结点数位和不大于k代表可达</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 四个方向的横纵坐标变化</span><br><span class="line">            for (int i &#x3D; 0; i &lt; dx.length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前结点移动一次后新横坐标</span><br><span class="line">                int tx &#x3D; x + dx[i];</span><br><span class="line">                &#x2F;&#x2F; 当前结点移动一次后新纵坐标</span><br><span class="line">                int ty &#x3D; y + dy[i];</span><br><span class="line">                &#x2F;&#x2F; 判断是否越界</span><br><span class="line">                if (tx &lt; m &amp;&amp; ty &lt; n &amp;&amp; tx &gt;&#x3D; 0 &amp;&amp; ty &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 未访问且可达将结点入队，设置已访问</span><br><span class="line">                    if (!used[tx][ty] &amp;&amp; flag) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                        used[tx][ty] &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 求数位和</span><br><span class="line">     *</span><br><span class="line">     * @param x</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int sum(int x) &#123;</span><br><span class="line">        int sumX &#x3D; 0;</span><br><span class="line">        while(x &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 累加上最低位的值</span><br><span class="line">            sumX +&#x3D; x % 10;</span><br><span class="line">            &#x2F;&#x2F; 舍弃低位</span><br><span class="line">            x &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sumX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/20200408012826997.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof&lt;/a&gt; 】&lt;br&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：m = 2, n = 3, k = 1&lt;br&gt;输出：3&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：m = 3, n = 1, k = 0&lt;br&gt;输出：1&lt;br&gt;提示：&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= n,m &amp;lt;= 100&lt;br&gt;0 &amp;lt;= k &amp;lt;= 20&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>旋转矩阵</title>
    <link href="https://kawhiz.github.io/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://kawhiz.github.io/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-07T04:12:00.000Z</published>
    <updated>2020-04-07T05:17:59.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci</a> 】<br>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p>示例 1:<br>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><p>示例 2:<br>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始直观的想另开一个数组存放每一个像素点顺时针旋转90度后的结果，最后再复制回去即可，没想到这样就双百了。。。。。。<br>问题的关键是找到顺时针旋转90度后每一个下标变化的规律，多写几个还是不难发现的</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">        int n &#x3D; matrix.length;</span><br><span class="line">        &#x2F;&#x2F; 额外开数组存放结果</span><br><span class="line">        int[][] res &#x3D; new int[n][n];</span><br><span class="line">        &#x2F;&#x2F; 顺时针旋转90度</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 每一处顺时针90度旋转下标的变化</span><br><span class="line">                res[j][n - i - 1] &#x3D; matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 复制回去</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[i][j] &#x3D; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/20200407121523278.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>另一种思路是矩阵通过对角线上下调换后，再左右对调也可达成同样的效果</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">        int n &#x3D; matrix.length;</span><br><span class="line">        int temp &#x3D; - 1;</span><br><span class="line">        &#x2F;&#x2F; 通过&quot;左上-右下&quot;对角线上下调换</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">                matrix[j][i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; - 1;</span><br><span class="line">        &#x2F;&#x2F; 左右调换</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n ; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; (n &gt;&gt; 1); j++, k--) &#123;</span><br><span class="line">                temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[i][k];</span><br><span class="line">                matrix[i][k] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/20200407010804117.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-matrix-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotate-matrix-lcci&lt;/a&gt; 】&lt;br&gt;给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;/p&gt;
&lt;p&gt;不占用额外内存空间能否做到？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;给定 matrix =&lt;br&gt;[&lt;br&gt;  [1,2,3],&lt;br&gt;  [4,5,6],&lt;br&gt;  [7,8,9]&lt;br&gt;],&lt;br&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;[&lt;br&gt;  [7,4,1],&lt;br&gt;  [8,5,2],&lt;br&gt;  [9,6,3]&lt;br&gt;]&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;给定 matrix =&lt;br&gt;[&lt;br&gt;  [ 5, 1, 9,11],&lt;br&gt;  [ 2, 4, 8,10],&lt;br&gt;  [13, 3, 6, 7],&lt;br&gt;  [15,14,12,16]&lt;br&gt;],&lt;br&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;[&lt;br&gt;  [15,13, 2, 5],&lt;br&gt;  [14, 3, 4, 1],&lt;br&gt;  [12, 6, 8, 9],&lt;br&gt;  [16, 7,10,11]&lt;br&gt;]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后的hexo恢复</title>
    <link href="https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/"/>
    <id>https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/</id>
    <published>2020-04-07T02:18:44.000Z</published>
    <updated>2020-04-07T03:13:23.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>win10重装系统后hexo博客如何恢复？</strong></p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="重装nodejs、git"><a href="#重装nodejs、git" class="headerlink" title="重装nodejs、git"></a>重装nodejs、git</h2><p><strong>去官网下载LTS版本</strong><br>node：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a><br>git：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a> 【git官网下载太慢可以在这里下载】</p><h2 id="重装hexo-cli"><a href="#重装hexo-cli" class="headerlink" title="重装hexo-cli"></a>重装hexo-cli</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-cli -g</code></p><h2 id="重新配置git个人信息、生成ssh密钥"><a href="#重新配置git个人信息、生成ssh密钥" class="headerlink" title="重新配置git个人信息、生成ssh密钥"></a>重新配置git个人信息、生成ssh密钥</h2><p><strong>git bash输入以下命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your github name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;your email&quot;</span><br></pre></td></tr></table></figure><p><strong>在提示文件夹处找到ssh密钥</strong><br><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407110652561.png" alt><br><strong>github上设置好ssh后不用每次git操作时都要提示输入账号密码</strong><br><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407110957452.png" alt></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103533188.png" alt></p><h2 id="保留删除文件"><a href="#保留删除文件" class="headerlink" title="保留删除文件"></a>保留删除文件</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103959930.png" alt></p><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407104150066.png" alt></p><h2 id="安装部署依赖"><a href="#安装部署依赖" class="headerlink" title="安装部署依赖"></a>安装部署依赖</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-deployer-git --save</code></p><h2 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h2><p><strong>执行完去看看是否推送成功</strong><br><code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;win10重装系统后hexo博客如何恢复？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://kawhiz.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-06T08:52:43.000Z</published>
    <updated>2020-04-06T09:47:36.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a> 】<br>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p>示例 2：<br>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>题目给了三种操作，直观发现对A（B）插入等价于对B（A）删除、对A替换等价于对B替换，操作的顺序不影响结果<br>一开始的直观想法采用BFS搜索每种操作的情况，但是考虑可能会及其耗时<br>由于是要找最优解，若问题含有最优子结构性质可以考虑使用动态规划来解决<br>设置一个二维数组dp(i)(j)代表代表A中前i个字母转换为B中前j个字母的最少操作次数<br>dp（i，j）问题的关键在于考虑d（i - 1， j）【d（i， j - 1）】只要再执行一次插入【删除】操作子问题和dp（i - 1， j - 1)是否需要再执行一次替换操作两者的最小值<br>拿A = “horse”和B = “ros”示例，过程如图</strong><br><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406054735596.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加一是为了判断空字符串的情况</span><br><span class="line">        int m &#x3D; word1.length() + 1;</span><br><span class="line">        int n &#x3D; word2.length() + 1;</span><br><span class="line">        &#x2F;&#x2F; 存放A中前m个和B中前n个字母得的少操作次数</span><br><span class="line">        int[][] dp &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 直观看到，如果其中一个为空字符串，那么操作次数取决于另一个的长度</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 同上</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断A、B中最后一个字符串是否相等</span><br><span class="line">                char ci &#x3D; word1.charAt(i - 1);</span><br><span class="line">                char cj &#x3D; word2.charAt(j - 1);</span><br><span class="line">                &#x2F;&#x2F; 若相等代表A、B在替换操作时跟其去除当前最后一个字母的情况相等</span><br><span class="line">                if(ci &#x3D;&#x3D; cj) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1]);</span><br><span class="line">                    &#x2F;&#x2F; 区别在于比较的最后一项多了加一（次操作）</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406045859234.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>求最优解一开始没往dp方向想，走了很多弯路。。。。。。</li><li>在分析好最优子结构和状态后，写完状态转化方程后，稍微考虑一下边界问题，很快就能编码解决问题，所以在动手之前还是要把问题分析清楚</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/edit-distance&lt;/a&gt; 】&lt;br&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;br&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：word1 = “horse”, word2 = “ros”&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;horse -&amp;gt; rorse (将 ‘h’ 替换为 ‘r’)&lt;br&gt;rorse -&amp;gt; rose (删除 ‘r’)&lt;br&gt;rose -&amp;gt; ros (删除 ‘e’)&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：word1 = “intention”, word2 = “execution”&lt;br&gt;输出：5&lt;br&gt;解释：&lt;br&gt;intention -&amp;gt; inention (删除 ‘t’)&lt;br&gt;inention -&amp;gt; enention (将 ‘i’ 替换为 ‘e’)&lt;br&gt;enention -&amp;gt; exention (将 ‘n’ 替换为 ‘x’)&lt;br&gt;exention -&amp;gt; exection (将 ‘n’ 替换为 ‘c’)&lt;br&gt;exection -&amp;gt; execution (插入 ‘u’)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-05T14:41:05.000Z</published>
    <updated>2020-04-05T14:56:51.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a> 】<br>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:<br>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>实现LRU的话关键在于如何判断移除哪个键值是最近最少未使用的，直观思路就是设置上次使用的时间戳以及使用次数<br>不过自己代码封装及其丑陋。。。<br>所以还是参考官方使用java已经封装得非常好看的LinkedHashMap，因为底层通过封装哈希表和双向链表保证了有序插入，同时实现了removeEldestEntry方法，这里cache容量满了的话要删除头部结点就是最近最少未使用的结点</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; cache的容量</span><br><span class="line">    private int capacity;</span><br><span class="line">    &#x2F;&#x2F; super(capacity, 0.75F, true)这里三个参数分别是容量、负载因子和模式，默认为插入模式存储，这里设置为访问模式存储</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        super(capacity, 0.75F, true);</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; super.getOrDefault(key, -1)这里如果查不到则返回默认值-1</span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        return super.getOrDefault(key, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        super.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果当前大小大于容量则需要移除最近最少使用的结点</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj &#x3D; new LRUCache(capacity);</span><br><span class="line"> * int param_1 &#x3D; obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/20200405105618555.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/lru-cache&lt;/a&gt; 】&lt;br&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;p&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );&lt;/p&gt;
&lt;p&gt;cache.put(1, 1);&lt;br&gt;cache.put(2, 2);&lt;br&gt;cache.get(1);       // 返回  1&lt;br&gt;cache.put(3, 3);    // 该操作会使得密钥 2 作废&lt;br&gt;cache.get(2);       // 返回 -1 (未找到)&lt;br&gt;cache.put(4, 4);    // 该操作会使得密钥 1 作废&lt;br&gt;cache.get(1);       // 返回 -1 (未找到)&lt;br&gt;cache.get(3);       // 返回  3&lt;br&gt;cache.get(4);       // 返回  4&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-04-04T03:31:37.000Z</published>
    <updated>2020-04-04T06:09:02.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a> 】<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png" alt><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>看图可以直观发现每一个柱子高度接水量跟左右两边柱子的最大高度相关<br>当前柱子接水量等于左右两边最大高度中的最小值减去当前高度<br>这里直接简单粗暴两边遍历算出各自最大值再拿最小值来计算最后累加每一个柱子接水量即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前高度左边的最大值</span><br><span class="line">        int maxLeft &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 当前高度右边的最大值</span><br><span class="line">        int maxRight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 一个往右一个往左、注意边界判断即可</span><br><span class="line">            int j &#x3D; i + 1, k &#x3D; i - 1;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往右查找右边最大高度</span><br><span class="line">            while(j &lt; n) &#123;</span><br><span class="line">                maxRight &#x3D; Math.max(height[j], maxRight);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往左查找左边最大高度</span><br><span class="line">            while(k &gt; -1) &#123;</span><br><span class="line">                maxLeft &#x3D; Math.max(height[k], maxLeft);</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量     </span><br><span class="line">            int temp &#x3D; (Math.min(maxRight, maxLeft) - height[i]);</span><br><span class="line">            if(temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意重新归零</span><br><span class="line">            maxRight &#x3D; 0;</span><br><span class="line">            maxLeft &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404114109687.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路I"><a href="#思路I" class="headerlink" title="思路I"></a>思路I</h2><p><strong>可以额外开数组记录中间结果而不用每次都在循环内再循环遍历左右最大值，拿极小的空间代价换取时间</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 分别存放i左右两边的最大值</span><br><span class="line">        int[] maxLeft &#x3D; new int[n];</span><br><span class="line">        int[] maxRight &#x3D; new int[n];</span><br><span class="line">        &#x2F;&#x2F; 最左边的左边以及最右边的右边最大值都为0</span><br><span class="line">        maxLeft[0] &#x3D; 0;</span><br><span class="line">        maxRight[n - 1] &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 记录i左边的最大值</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            maxLeft[i] &#x3D; Math.max(height[i - 1], maxLeft[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录i右边的最大值</span><br><span class="line">        for (int i &#x3D; n - 2; i &gt; 0; i--) &#123;</span><br><span class="line">            maxRight[i] &#x3D; Math.max(height[i + 1], maxRight[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量</span><br><span class="line">            int temp &#x3D; (Math.min(maxRight[i], maxLeft[i]) - height[i]);</span><br><span class="line">            if (temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404015530001.png" alt></p><h2 id="思路II"><a href="#思路II" class="headerlink" title="思路II"></a>思路II</h2><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt; 】&lt;br&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;&lt;img src=&quot;/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png&quot; alt&gt;&lt;br&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;输出: 6&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字符串转换整数atoi</title>
    <link href="https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/"/>
    <id>https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/</id>
    <published>2020-04-03T07:30:08.000Z</published>
    <updated>2020-04-03T07:53:29.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a> 】<br>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:<br>输入: “42”<br>输出: 42</p><p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除多余的空格然后记录正负号，千万注意对Integer越界情况进行判断<br>问题的关键在于res = res * 10 + num &gt; Integer.MAX_VALUE这里计算出来的结果可能越界所以必须先判断再计算最后根据正负号对应添加符号<br>int num = c - ‘0’;这里通过ASCII计算可以将char c转化为对应的int</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去前面和后面多余的空格</span><br><span class="line">        str &#x3D; str.trim();</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回无效</span><br><span class="line">        if(&quot;&quot;.equals(str)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否负数</span><br><span class="line">        boolean isNegative &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 字符串下标</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        char c &#x3D; str.charAt(i);</span><br><span class="line">        &#x2F;&#x2F; 遇到负号</span><br><span class="line">        if(c &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            isNegative &#x3D; true;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到正号</span><br><span class="line">        &#125; else if(c &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到无效数字</span><br><span class="line">        &#125; else if(!Character.isDigit(c)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 遇到0 ~ 9</span><br><span class="line">        while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i))) &#123;</span><br><span class="line">            c &#x3D; str.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 将字符转化为int</span><br><span class="line">            int num &#x3D; c - &#39;0&#39;;</span><br><span class="line">            &#x2F;&#x2F; 当res * 10 + num &gt; Integer.MAX_VALUE越界、所以先判断res的范围</span><br><span class="line">            if (res &gt; (Integer.MAX_VALUE - num) &#x2F; 10) &#123;</span><br><span class="line">                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不越界则正常加</span><br><span class="line">            res &#x3D; res * 10 + num;</span><br><span class="line">            &#x2F;&#x2F; 判断下一个</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return isNegative ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/20200403033744892.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>我一开始考虑使用一个StringBuffer来接受结果但是判断越界的时候又需要重新转化非常麻烦所以用int来接受结果是比较好的</li><li>我一开始自己写了去除空格的判断以及是否为数字的判断导致代码非常臃肿难看低效，因此这里都用String.trim()、Character.isDigit()这些库函数代替</li><li>稍微注意一下下标越界问题**</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/string-to-integer-atoi&lt;/a&gt; 】&lt;br&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;br&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：&lt;br&gt;如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。&lt;br&gt;假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。&lt;br&gt;该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。&lt;br&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。&lt;br&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0 。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;本题中的空白字符只包括空格字符 ‘ ‘ 。&lt;br&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “42”&lt;br&gt;输出: 42&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: “   -42”&lt;br&gt;输出: -42&lt;br&gt;解释: 第一个非空白字符为 ‘-‘, 它是一个负号。&lt;br&gt;     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;输入: “4193 with words”&lt;br&gt;输出: 4193&lt;br&gt;解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。&lt;/p&gt;
&lt;p&gt;示例 4:&lt;br&gt;输入: “words and 987”&lt;br&gt;输出: 0&lt;br&gt;解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。&lt;br&gt;     因此无法执行有效的转换。&lt;/p&gt;
&lt;p&gt;示例 5:&lt;br&gt;输入: “-91283472332”&lt;br&gt;输出: -2147483648&lt;br&gt;解释: 数字 “-91283472332” 超过 32 位有符号整数范围。&lt;br&gt;     因此返回 INT_MIN (−231) 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>生命游戏</title>
    <link href="https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-02T11:13:46.000Z</published>
    <updated>2020-04-02T12:38:43.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/game-of-life" target="_blank" rel="noopener">https://leetcode-cn.com/problems/game-of-life</a> 】<br>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：<br>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]<br>进阶：<br>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。<br>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>可以考虑采用bfs搜索，备份原来的状态<br>直接简单粗暴将死细胞和活细胞分别入队然后各自判断周围8个位置活细胞的数目再根据规则修改状态即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 待处理的活细胞或者死细胞、队列存放数组，数组第一位存值，第二位存行数、第三位存列数</span><br><span class="line">    LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;&#x2F; 存放最终结果</span><br><span class="line">    int[][] res;</span><br><span class="line">    &#x2F;&#x2F; 8个方向数组</span><br><span class="line">    int[] dx &#x3D; &#123;-1, -1, -1, 0, 0, 1, 1, 1&#125;;</span><br><span class="line">    int[] dy &#x3D; &#123;-1, 0, 1, -1, 1, -1, 0, 1&#125;;</span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        res &#x3D; new int[board.length][board[0].length];</span><br><span class="line">        &#x2F;&#x2F; 活细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 1);</span><br><span class="line">        &#x2F;&#x2F; 死细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 0);</span><br><span class="line">        &#x2F;&#x2F; 将结果数组复制回原数组</span><br><span class="line">        for(int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;board[0].length; j++) &#123;</span><br><span class="line">                board[i][j] &#x3D; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; bfs搜索</span><br><span class="line">    public void bfs(int[][] board, int flag) &#123;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] node &#x3D; queue.poll();</span><br><span class="line">            int val &#x3D; node[0];</span><br><span class="line">            int i &#x3D; node[1];</span><br><span class="line">            int j &#x3D; node[2];</span><br><span class="line">            int count1 &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F; 统计旁边八个位置的活细胞数目</span><br><span class="line">            for (int k &#x3D; 0; k &lt; 8; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 横坐标</span><br><span class="line">                int tx &#x3D; i + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 纵坐标</span><br><span class="line">                int ty &#x3D; j + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界则跳过</span><br><span class="line">                if (tx &lt; 0 || tx &gt;&#x3D; board.length || ty &lt; 0 || ty &gt;&#x3D; board[0].length) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[tx][ty] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 活细胞周围细胞数小于2或者大于3死亡、等于2或者等于3仍然存活；</span><br><span class="line">            if (flag &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                if (count1 &lt; 2 || count1 &gt; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 2 || count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 死细胞周围有三个活细胞则复活</span><br><span class="line">            if (flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意活细胞数清零</span><br><span class="line">            count1 &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402072054309.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>因为额外开数组和各自判断对速度和内存影响极大，但是为了同时记录活细胞和死细胞当下和先前的状态从而不影响活细胞数目判断，可以考虑自己设置其他状态码<br>这里用-1代表从活细胞到死细胞、2代表从死细胞到活细胞，最后处理完注意更新新状态<br>8个位置的横纵坐标变化只有1，0，-1，但是要注意排除0，0（自身）的情况</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从活细胞到死细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int liveToDead &#x3D; -1;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从死细胞到活细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int deadToLive &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 3个坐标值变化数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int[] change &#x3D; &#123;0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行数</span><br><span class="line">        int m &#x3D; board.length;</span><br><span class="line">        &#x2F;&#x2F; 列数</span><br><span class="line">        int n &#x3D; board[0].length;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 开始从第一个细胞遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 周围8个位置活细胞数目</span><br><span class="line">                int countLive &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 对每个细胞周围8个方向判断</span><br><span class="line">                for (int k &#x3D; 0; k &lt; change.length; k++) &#123;</span><br><span class="line">                    for (int l &#x3D; 0; l &lt; change.length; l++) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 排除当前细胞自身</span><br><span class="line">                        if (change[k] !&#x3D; 0 || change[l] !&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 周围位置横坐标</span><br><span class="line">                            int x &#x3D; (i + change[k]);</span><br><span class="line">                            &#x2F;&#x2F; 周围位置纵坐标</span><br><span class="line">                            int y &#x3D; (j + change[l]);</span><br><span class="line">                            &#x2F;&#x2F; 不越界的情况下周围是否有活细胞、注意判断要包括活细胞到死细胞这种情况</span><br><span class="line">                            boolean hasLiveCell &#x3D; (x &gt;&#x3D; 0 &amp;&amp; x &lt; m) &amp;&amp; (y &gt;&#x3D; 0 &amp;&amp; y &lt; n) &amp;&amp; (board[x][y] &#x3D;&#x3D; 1 || board[x][y] &#x3D;&#x3D; liveToDead);</span><br><span class="line">                            if (hasLiveCell) &#123;</span><br><span class="line">                                countLive++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 活细胞到死细胞</span><br><span class="line">                if (countLive &lt; 2 || countLive &gt; 3) &#123;</span><br><span class="line">                    if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        board[i][j] &#x3D; liveToDead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 死细胞到活细胞</span><br><span class="line">                if (countLive &#x3D;&#x3D; 3 &amp;&amp; board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    board[i][j] &#x3D; deadToLive;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取更新后的状态</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; liveToDead) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; deadToLive) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402083733078.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/game-of-life&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/game-of-life&lt;/a&gt; 】&lt;br&gt;根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。&lt;/p&gt;
&lt;p&gt;给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：&lt;/p&gt;
&lt;p&gt;如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；&lt;br&gt;如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；&lt;br&gt;如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；&lt;br&gt;如果死细胞周围正好有三个活细胞，则该位置死细胞复活；&lt;br&gt;根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;[&lt;br&gt;  [0,1,0],&lt;br&gt;  [0,0,1],&lt;br&gt;  [1,1,1],&lt;br&gt;  [0,0,0]&lt;br&gt;]&lt;br&gt;输出：&lt;br&gt;[&lt;br&gt;  [0,0,0],&lt;br&gt;  [1,0,1],&lt;br&gt;  [0,1,1],&lt;br&gt;  [0,1,0]&lt;br&gt;]&lt;br&gt;进阶：&lt;br&gt;你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。&lt;br&gt;本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-04-01T08:32:31.000Z</published>
    <updated>2020-04-01T09:41:39.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a> 】<br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>左右括号必须一一匹配，可以考虑使用栈辅助存放所有左括号然后遇到一个右括号弹出栈顶元素判断是否匹配，最后栈空代表一一匹配成功<br>惯性思维考虑map的key存放左括号、value存放右括号，这样让左括号入栈后，每次遍历到一个右括号和栈顶的元素判断是否相等比key存放右括号、value存放左括号麻烦，时间慢了2倍</strong></p><h1 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放右括号、value存放左括号</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;)&#39;, &#39;(&#39;);</span><br><span class="line">        map.put(&#39;]&#39;, &#39;[&#39;);</span><br><span class="line">        map.put(&#39;&#125;&#39;, &#39;&#123;&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 让左括号入栈</span><br><span class="line">            if(!map.containsKey(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 栈顶是左括号</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                if(top !&#x3D; map.get(c)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401043902216.png" alt></p><h1 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 辅助栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放左括号、value存放右括号、这里注意跟方案I的区别</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;(&#39;, &#39;)&#39;);</span><br><span class="line">        map.put(&#39;[&#39;, &#39;]&#39;);</span><br><span class="line">        map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);</span><br><span class="line">        &#x2F;&#x2F; 防止map.get(key)异常</span><br><span class="line">        map.put(&#39;X&#39;, &#39;X&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 左括号入栈、这里注意跟方案I的区别</span><br><span class="line">            if(!map.containsValue(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里注意判断栈为空代表只有单独的右括号，所以匹配失败</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                &#x2F;&#x2F; 这里注意跟方案I的区别</span><br><span class="line">                if(c !&#x3D; map.get(top)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401045523605.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/valid-parentheses&lt;/a&gt; 】&lt;br&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;br&gt;有效字符串需满足：&lt;br&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;注意空字符串可被认为是有效字符串。&lt;br&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: “()”&lt;br&gt;输出: true&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: “()[]{}”&lt;br&gt;输出: true&lt;br&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: “(]”&lt;br&gt;输出: false&lt;br&gt;示例 4:&lt;/p&gt;
&lt;p&gt;输入: “([)]”&lt;br&gt;输出: false&lt;br&gt;示例 5:&lt;/p&gt;
&lt;p&gt;输入: “{[]}”&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
