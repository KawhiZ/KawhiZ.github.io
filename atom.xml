<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kawhiz.github.io/"/>
  <updated>2020-05-08T20:00:41.641Z</updated>
  <id>https://kawhiz.github.io/</id>
  
  <author>
    <name>庄健彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x的平方根</title>
    <link href="https://kawhiz.github.io/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://kawhiz.github.io/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</id>
    <published>2020-05-08T19:46:46.000Z</published>
    <updated>2020-05-08T20:00:41.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx</a> 】</p><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br>输入: 4<br>输出: 2</p><p>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>当前我们可以使用库函数Math.sqrt(x)或者Math.pow(x, 0.5)，如果不借助库函数的话则在数目不大的情况下可以直接从1开始枚举，找到一个临界即可，注意int的边界问题即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x &#x3D;&#x3D; 2147483647) &#123;</span><br><span class="line">            return 46340;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 直接暴力枚举</span><br><span class="line">        while(i &lt; x) &#123;</span><br><span class="line">            if(i * i &#x3D;&#x3D; x) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125; else if(i * i &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i - 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/20200509035333879.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>数目多的情况下在有序数列中自然而然可以使用二分搜索来提高效率，注意一下int越界的问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; x;</span><br><span class="line">        int res &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 二分查找</span><br><span class="line">        while(low &lt;&#x3D; high) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意这里不写成mid &#x3D; (low + high) &#x2F; 2 是为了当low、high非常大时int不越界</span><br><span class="line">            int mid &#x3D; low + (high - low) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F; 必须强转为double否则非常容易越界</span><br><span class="line">            if((double)mid * mid &lt;&#x3D; x) &#123;</span><br><span class="line">                res &#x3D; mid;</span><br><span class="line">                low &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/09/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/20200509035212671.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/sqrtx&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;实现 int sqrt(int x) 函数。&lt;br&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;br&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: 4&lt;br&gt;输出: 2&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: 8&lt;br&gt;输出: 2&lt;br&gt;说明: 8 的平方根是 2.82842…,&lt;br&gt;     由于返回类型是整数，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形</title>
    <link href="https://kawhiz.github.io/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://kawhiz.github.io/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2020-05-08T08:46:42.000Z</published>
    <updated>2020-05-08T09:51:16.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square</a> 】<br>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>找最优解的话优先考虑能否用dp解决，有几个关键<br>（1）要找都为1的最大面积正方形，假如能找到最大的边长再取平方问题即迎刃而解<br>（2）dp(i)(j)代表从(0)(0)到(i)(j)处的最大正方形数目（因为边长为1，也就是最大边长），状态转移式如下：<br>    * 直观可以判断在第0行或者第0列的dp值为原来的值， dp(i)(j) = matrix(i)(j)<br>    * 其他位置值等于左、上、左上最小值加一，核心状态转移式：dp(i)(j) = min(dp(i - 1)(j), dp(i)(j - 1), dp(i - 1)(j - 1)) + 1（matrix(i)(j) == ‘1’）<br>    * dp(i)(j) = 0 (martix(i)(j) == ‘0’)<br>（3）注意char和int的互相转化即可int i，char c = (char)(‘0’ + i)或char c = Character.forDigit(i,10);int i = char - ‘0’</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int maximalSquare(char[][] matrix) &#123;</span><br><span class="line">        int m &#x3D; matrix.length;</span><br><span class="line">        if(m &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; dp[i][j]代表从0， 0到i、j为右下边界的最大边长</span><br><span class="line">        int [][] dp &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 最大边长</span><br><span class="line">        int maxSide &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 初始化</span><br><span class="line">                if(i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 注意原来是char类型</span><br><span class="line">                    dp[i][j] &#x3D; matrix[i][j] - &#39;0&#39;;</span><br><span class="line">                    &#x2F;&#x2F; 核心状态转移式：取其左、上和左上三者最小值加一</span><br><span class="line">                &#125; else if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i- 1][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果是&#39;0&#39;重新修改为0,这一处也可省略，因为本来dp初始化就是0</span><br><span class="line">                if(matrix[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 取每次的最大边长</span><br><span class="line">                maxSide &#x3D; Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记得计算面积</span><br><span class="line">        return maxSide * maxSide;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/08/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/20200508044952087.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximal-square&lt;/a&gt; 】&lt;br&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;1 0 1 0 0&lt;br&gt;1 0 1 1 1&lt;br&gt;1 1 1 1 1&lt;br&gt;1 0 0 1 0&lt;/p&gt;
&lt;p&gt;输出: 4&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>另一个树的子树</title>
    <link href="https://kawhiz.github.io/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</id>
    <published>2020-05-07T03:31:22.000Z</published>
    <updated>2020-05-07T04:01:57.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtree-of-another-tree</a> 】<br>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。<br>示例 1:<br>给定的树 s:<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113307497.png" alt><br>给定的树 t：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113318398.png" alt><br>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。<br>示例 2:<br>给定的树 s：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113335803.png" alt><br>给定的树 t：<br><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113345676.png" alt><br>返回 false。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>想要判断一棵树是否是另一个树的子树，可以dfs暴力遍历源树s，再将其跟目标树t通过再一次dfs进行比较是否相等，有几个关键<br>（1）空树是任何树的子树<br>（2）非空树一定不是空树的子树<br>（3）如果判断两颗树相同？只要源子树s中含有跟目标子树t相同的子树结构和值即可，两个指针初始指向两颗树根结点，再同步dfs递归判断<br>（4）因为包含了双递归，特别要注意每次递归的出口，否则非常容易无限递归栈内存溢出。。。</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空树t是任何树的子树</span><br><span class="line">        if(t &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非空树t一定不是空树s的子树</span><br><span class="line">        if(s &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历s结点，同时和t比较是否相同</span><br><span class="line">        return isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断两棵树是否相同</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        &#x2F;&#x2F; 两颗空树相同</span><br><span class="line">        if(p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 空树一定不和非空树结构相同</span><br><span class="line">        if(p &#x3D;&#x3D; null || q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断值是否相等</span><br><span class="line">        if(p.val !&#x3D; q.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 两个指针同步移动判断</span><br><span class="line">        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113215580.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/subtree-of-another-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/subtree-of-another-tree&lt;/a&gt; 】&lt;br&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。&lt;br&gt;示例 1:&lt;br&gt;给定的树 s:&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113307497.png&quot; alt&gt;&lt;br&gt;给定的树 t：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113318398.png&quot; alt&gt;&lt;br&gt;返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。&lt;br&gt;示例 2:&lt;br&gt;给定的树 s：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113335803.png&quot; alt&gt;&lt;br&gt;给定的树 t：&lt;br&gt;&lt;img src=&quot;/2020/05/07/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/20200507113345676.png&quot; alt&gt;&lt;br&gt;返回 false。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="https://kawhiz.github.io/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-05-05T03:31:29.000Z</published>
    <updated>2020-05-05T04:14:10.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a> 】<br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114201940.png" alt><br><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114212932.png" alt></p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>主要利用BST中序序列为升序这一性质进行验证，可以有递归和辅助栈迭代判断两种思路，几个关键：<br>（1）BST性质中结点是严格大于左子树结点，严格小于右子数结点，即不存在等于的情况<br>（2）树还是尽量采用递归，代码比较清晰易懂，利用辅助栈迭代容易出错</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 存放中序遍历结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        &#x2F;&#x2F; 判断中序遍历是否为升序</span><br><span class="line">        for(int i &#x3D; 1; i &lt; list.size(); i++) &#123;</span><br><span class="line">            if(list.get(i) &lt;&#x3D; list.get(i - 1)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 递归实现中序遍历，结果存放数组</span><br><span class="line">    public void dfs(TreeNode node) &#123;</span><br><span class="line">        &#x2F;&#x2F; 搜索左子树</span><br><span class="line">        if(node.left !&#x3D; null) &#123;</span><br><span class="line">            dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        &#x2F;&#x2F; 搜索右子树</span><br><span class="line">        if(node.right !&#x3D; null) &#123;</span><br><span class="line">            dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114233057.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>辅助栈迭代的中序遍历实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F; 非递归利用栈迭代实现中序遍历</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 测试用例的边界包含Integer.MAX_VALUE,所以要使用double</span><br><span class="line">        double preNodeVal &#x3D; - Double.MAX_VALUE;</span><br><span class="line">        TreeNode curNode &#x3D; root;</span><br><span class="line">        while(!stack.isEmpty() || curNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 未到底一直将左子结点入栈</span><br><span class="line">            while(curNode !&#x3D; null) &#123;</span><br><span class="line">                stack.push(curNode);</span><br><span class="line">                curNode &#x3D; curNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 到底了弹出</span><br><span class="line">            curNode &#x3D; stack.pop();</span><br><span class="line">            &#x2F;&#x2F; 如果不满足</span><br><span class="line">            if(curNode.val &lt;&#x3D; preNodeVal) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 更新中序遍历前一节点值</span><br><span class="line">            preNodeVal &#x3D; curNode.val;</span><br><span class="line">            &#x2F;&#x2F; 更新当前结点</span><br><span class="line">            curNode &#x3D; curNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505121054198.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/validate-binary-search-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/validate-binary-search-tree&lt;/a&gt; 】&lt;br&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;假设一个二叉搜索树具有如下特征：&lt;br&gt;节点的左子树只包含小于当前节点的数。&lt;br&gt;节点的右子树只包含大于当前节点的数。&lt;br&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;br&gt;&lt;img src=&quot;/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114201940.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;/2020/05/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/20200505114212932.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏II</title>
    <link href="https://kawhiz.github.io/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>https://kawhiz.github.io/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2020-05-04T02:17:53.000Z</published>
    <updated>2020-05-04T02:33:41.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii</a> 】</p><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:<br>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>说明:<br>假设你总是可以到达数组的最后一个位置。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>从目的地最后的位置来看，倒数前一次跳跃每次如果每次能找到一个离起点更近的位置则可以节省步数，最后找到起始位置即可，几个关键问题<br>（1）注意在找到一个位置后更新跳跃倒数前一个位置以及跳出循环<br>（2）外层循环是到起始位置则结束</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最少跳跃步数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 初始为最后的位置</span><br><span class="line">        int pos &#x3D; n - 1;</span><br><span class="line">        &#x2F;&#x2F; 找到初始位置则结束</span><br><span class="line">        while (pos &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从左往右贪心地选择离最后位置最远的地方</span><br><span class="line">            for (int i &#x3D; 0; i &lt; pos; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果可达</span><br><span class="line">                if (i + nums[i] &gt;&#x3D; pos) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    &#x2F;&#x2F; 更新跳跃倒数前一个位置</span><br><span class="line">                    pos &#x3D; i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/20200504102947332.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>从起始位置来看，每次选择能跳跃的更远的位置来考虑下一步跳跃则可以节省步数，最后到达目的地即可，有几个关键<br>（1）如何实现？这种思路起始很容易想到，但是实际还是不容易想到设置一个边界来实现，每次到达边界则更新边界<br>（2）最后的位置不需要遍历，必定能到达最后的位置不用再跳</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最少跳跃步数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 当前最远跳跃位置</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 边界</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意不需要遍历到最后一个元素</span><br><span class="line">        for(int cur &#x3D; 0; cur &lt; n - 1; cur++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最大跳跃位置</span><br><span class="line">            curMax &#x3D; Math.max(curMax, cur + nums[cur]);</span><br><span class="line">            &#x2F;&#x2F; 到达边界则更新边界和跳跃步数</span><br><span class="line">            if(cur &#x3D;&#x3D; end) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                end &#x3D; curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/04/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/20200504102449553.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/jump-game-ii&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;你的目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [2,3,1,1,4]&lt;br&gt;输出: 2&lt;br&gt;解释: 跳到最后一个位置的最小跳跃数是 2。&lt;br&gt;     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。&lt;br&gt;说明:&lt;br&gt;假设你总是可以到达数组的最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大子序和</title>
    <link href="https://kawhiz.github.io/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>https://kawhiz.github.io/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2020-05-03T06:33:16.000Z</published>
    <updated>2020-05-03T07:15:53.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a> 】<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>进阶:<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>为了在O（n）时间内肯定没法尝试双重循环暴力求解，那么因为为了使累加和最大，肯定是尽可能的加上正数，如果之前的累加和已经小于零，代表前面含有负数直接舍弃，否则继续尝试累加找最大值<br>贪心思想：如果之前的累加和小于零，则舍弃之前的数列，累加和则是当前位置的数，否则累加上当前位置的数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    &#x2F;&#x2F; 空数组返回0</span><br><span class="line">    if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 只有一个最大子序和为本身</span><br><span class="line">    int res &#x3D; nums[0];</span><br><span class="line">    &#x2F;&#x2F; 累加和</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 贪心思想：若当前位置之前的和小于零，则丢弃之前的数列</span><br><span class="line">    for(int num : nums) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前累加和大于零</span><br><span class="line">        if(sum &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 则可以继续累加下一个数待判断</span><br><span class="line">            sum +&#x3D; num;</span><br><span class="line">            &#x2F;&#x2F; 丢弃当前位置之前的数列，指望下一个数来使得当前子序和最大</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum &#x3D; num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 取最大子序和</span><br><span class="line">        res &#x3D; Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/20200503024233277.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>怎么说呢，不同于一般dp，之前一般都是返回dp中的最后一位较多，这里仍需取最大值，跟前面贪心类似，可能更清晰易懂，问题的关键：<br>（1）dpi代表前i位的最大累加和<br>（2）动态规划思想：若前一位置为正数，将其加到当前位置上<br>（3）状态转移式dp(i) = nums(i) + dp(i - 1)（dp(i - 1) &gt; 0）、dp（i） = nums(i)(dp(i - 1) &lt;= 0)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 空数组返回0</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        int [] dp &#x3D; new int[n];</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        int res &#x3D; nums[0];</span><br><span class="line">        &#x2F;&#x2F; i从1开始</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果前一位大于零，则继续累加到当前位置上</span><br><span class="line">            if(dp[i - 1] &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 状态转移式</span><br><span class="line">                dp[i] &#x3D; nums[i] + dp[i - 1];</span><br><span class="line">                &#x2F;&#x2F; 否则保持不变</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 取最大值</span><br><span class="line">            res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/20200503031552608.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-subarray&lt;/a&gt; 】&lt;br&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符子串的最长子串</title>
    <link href="https://kawhiz.github.io/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://kawhiz.github.io/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2020-05-02T04:08:18.000Z</published>
    <updated>2020-05-02T04:28:13.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a> 】</p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>参照官方的思路【<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/】，有几个关键问题" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/】，有几个关键问题</a><br>（1）如何对子串中字符判重？注意子串必须是连续的，使用HshSet可以很好解决<br>（2）如何做到比暴力枚举所有情况更优？子串问题常见的滑动窗口双指针问题，一个指向起始位置，一个指向结束位置，如果结束位置未到尾且没有和当前子串重复的字符则一直向右扩大当前窗口长度，否则记录最大长度<br>（3）为什么在左指针向右移动的时候，我们需要从哈希集合中移除一个字符，同时在右指针向右移动的时候，我们需要往哈希集合中添加一个字符呢？前者从窗口位置很直观看出，起始位置移动后，当前子串不包含该位置字符了，判重也不需要考虑该位置，后者是因为我们要找一个最长且不重复的子串<br>（4）子串长度如何计算？当前不重复子串长度很明显就是窗口长度，即结束位置end - 起始位置start</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        &#x2F;&#x2F; 空字符</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 长度为1的字符</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 子串结束的位置</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 无重复最长子串长度</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; set判重</span><br><span class="line">        HashSet&lt;Character&gt; set &#x3D; new HashSet&lt;Character&gt;();</span><br><span class="line">        for (int start &#x3D; 0; start &lt; n; start++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 滑动窗口起始位置右移注意移除前一个起始位置里set字符</span><br><span class="line">            if (start !&#x3D; 0) &#123;</span><br><span class="line">                set.remove(s.charAt(start - 1));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 未到尾以及当前子串没有重复字符则加入set，同时继续扩大窗口</span><br><span class="line">            while (end &lt; n &amp;&amp; !set.contains(s.charAt(end))) &#123;</span><br><span class="line">                set.add(s.charAt(end));</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 取当前窗口长度最大值即是无重复子串长度的最大值</span><br><span class="line">            res &#x3D; Math.max(res, end - start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/20200502121252902.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “abcabcbb”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: “bbbbb”&lt;br&gt;输出: 1&lt;br&gt;解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;输入: “pwwkew”&lt;br&gt;输出: 3&lt;br&gt;解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。&lt;br&gt;     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://kawhiz.github.io/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://kawhiz.github.io/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-01T03:38:19.000Z</published>
    <updated>2020-05-01T03:59:02.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a> 】</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>合并两个有序链表直观的可以联想到归并排序，但是在链表中合并新链表则可以使用尾插法，有几个关键问题<br>（1）一般都是通过设置空数据域的头指针来指向实际的第一个元素，方便编码<br>（2）注意遍历两条链表时循环条件的判断，存在一条链到尾时则可以跳出循环直接拼接另一条链<br>（3）注意最后返回头指针的下一个结点即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 头指针</span><br><span class="line">        ListNode res &#x3D; new ListNode();</span><br><span class="line">        &#x2F;&#x2F; 尾指针</span><br><span class="line">        ListNode tailer &#x3D; res;</span><br><span class="line">        &#x2F;&#x2F; 类似归并排序过程中使用尾插法</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val) &#123;</span><br><span class="line">                tailer.next &#x3D; l1;</span><br><span class="line">                tailer &#x3D; tailer.next;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tailer.next &#x3D; l2;</span><br><span class="line">                tailer &#x3D; tailer.next;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 一条链到头则直接拼接另一条链即可</span><br><span class="line">        if(l1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            tailer.next &#x3D; l2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tailer.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意从头指针的下一个返回</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/20200501114835981.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists&lt;/a&gt; 】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="https://kawhiz.github.io/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>https://kawhiz.github.io/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/</id>
    <published>2020-04-30T03:37:11.000Z</published>
    <updated>2020-04-30T03:43:27.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a> 】</p><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。<br>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：<br>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>直观的直接去计算每一位的平方和判断是否为一即可，这里主要还是考虑循环跳出条件，这里执行10次仍计算不出来则断言为非快乐数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        while(count &lt; 10) &#123;</span><br><span class="line">            n &#x3D; sum(n);</span><br><span class="line">            count++;</span><br><span class="line">            &#x2F;&#x2F; 若为快乐数则跳出</span><br><span class="line">            if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行10次仍计算不出来断言为非快乐数</span><br><span class="line">        if(count &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算每一位的平方和</span><br><span class="line">    public int sum(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(n !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取最低位</span><br><span class="line">            int temp &#x3D; n % 10;</span><br><span class="line">            &#x2F;&#x2F; 累加平方和</span><br><span class="line">            res +&#x3D; (temp * temp);</span><br><span class="line">            &#x2F;&#x2F; 舍弃最低位</span><br><span class="line">            n &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/30/%E5%BF%AB%E4%B9%90%E6%95%B0/20200430113930338.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/happy-number&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/happy-number&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;br&gt;「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。&lt;br&gt;如果 n 是快乐数就返回 True ；不是，则返回 False 。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：19&lt;br&gt;输出：true&lt;br&gt;解释：&lt;br&gt;12 + 92 = 82&lt;br&gt;82 + 22 = 68&lt;br&gt;62 + 82 = 100&lt;br&gt;12 + 02 + 02 = 1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>https://kawhiz.github.io/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-04-24T04:22:11.000Z</published>
    <updated>2020-04-24T04:40:53.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a> 】<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:<br>输入: [7,5,6,4]<br>输出: 5</p><p>限制：<br>0 &lt;= 数组长度 &lt;= 50000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始直接暴力破解，果不其然超时,后来还是参考了官方题解归并排序的思想，主要有几个关键问题：<br>（1）归并排序为什么就能够在O（nlogn）时间内统计逆序对数目？如果右子数组比左子数组大，那么逆序对就是当前左子数组所有数的和（注意左右子数组都是有序的前提下），以【7，5，6，4】为例，当回溯到【5，7】，【4，6】时5和4比较，4小所以当前含有【5，4】，【7，4】两个逆序对（左子数组的长度）；<br>（2）归并排序中递归分治的出口是什么？很明显就是只有一个元素则必定有序<br>（3）注意当left、right很大时，二分取（left + right） / 2 可能会溢出，所以用int mid = left + (right - left) / 2代替</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reversePairs(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 如果只有0、1个数，则不存在逆序对</span><br><span class="line">        if(n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 临时数组</span><br><span class="line">        int[] temp &#x3D; new int[n];</span><br><span class="line">        return reversePairs(0, n - 1, nums, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    public int reversePairs(int left, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 子数组只有一个必定有序</span><br><span class="line">        if (left &#x3D;&#x3D; right) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 逆序对</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意（left + right） &#x2F; 2 可能会溢出</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 左右两边逆序对数目</span><br><span class="line">        int leftCount &#x3D; reversePairs(left, mid, nums, temp);</span><br><span class="line">        int rightCount &#x3D; reversePairs(mid + 1, right, nums, temp);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 横跨左右逆序对数目</span><br><span class="line">        int crossCount &#x3D; mergeSort(left, mid, right, nums, temp);</span><br><span class="line">        return leftCount + rightCount + crossCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 归并回原数组</span><br><span class="line">     * @param left</span><br><span class="line">     * @param mid</span><br><span class="line">     * @param right</span><br><span class="line">     * @param nums</span><br><span class="line">     * @param temp</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int mergeSort(int left, int mid, int right, int[] nums, int[] temp) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先保存在临时数组</span><br><span class="line">        for(int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 左子数组第一个</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        &#x2F;&#x2F; 右子数组第一个</span><br><span class="line">        int j &#x3D; mid + 1;</span><br><span class="line"></span><br><span class="line">        for (int k &#x3D; left; k &lt;&#x3D; right; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果左边合并结束，只能合并右边</span><br><span class="line">            if (i &#x3D;&#x3D; mid + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 如果右边合并结束，只能合并左边</span><br><span class="line">            &#125; else if (j &#x3D;&#x3D; right + 1) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 如果左边的小则代表不存在逆序对，直接合并</span><br><span class="line">            &#125; else if (temp[i] &lt;&#x3D; temp[j]) &#123;</span><br><span class="line">                nums[k] &#x3D; temp[i++];</span><br><span class="line">                &#x2F;&#x2F; 否则计算逆序对</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[k] &#x3D; temp[j++];</span><br><span class="line">                &#x2F;&#x2F; 计算的关键代码</span><br><span class="line">                count +&#x3D; (mid - i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/20200424122857899.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof&lt;/a&gt; 】&lt;br&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;0 &amp;lt;= 数组长度 &amp;lt;= 50000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-04-20T01:57:56.000Z</published>
    <updated>2020-04-20T02:30:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a> 】<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:<br>输入:<br>11110<br>11010<br>11000<br>00000<br>输出: 1</p><p>示例 2:<br>输入:<br>11000<br>11000<br>00100<br>00011<br>输出: 3<br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>比较经典的题目，仍然采用bfs的一般思路，遍历二维数组，找到一个陆地入队，设置已访问，对陆地周围进行搜索，符合条件入队，再设置已访问，有几个注意的点<br>（1）注意初始二维数组类型是char而不是int<br>（2）注意每次搜索完必须设置已访问，这里可以直接将访问过位置设置为’0’或者其他标记均可（设置成零的话执行是最快的），这里无需额外开一个数组记录<br>（3）注意岛屿的数目即是bfs搜索的次数</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 岛屿数加一</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    &#x2F;&#x2F; 陆地入队</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 陆地访问过则置为&#39;0&#39;</span><br><span class="line">                    grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">                    while(!queue.isEmpty()) &#123;</span><br><span class="line">                        int[] point &#x3D; queue.poll();</span><br><span class="line">                        &#x2F;&#x2F; 当前横坐标</span><br><span class="line">                        int x &#x3D; point[0];</span><br><span class="line">                        &#x2F;&#x2F; 当前纵坐标</span><br><span class="line">                        int y &#x3D; point[1];</span><br><span class="line">                        &#x2F;&#x2F; 搜索该陆地四周</span><br><span class="line">                        for(int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 四周新的横坐标</span><br><span class="line">                            int tx &#x3D; x + dx[k];</span><br><span class="line">                            &#x2F;&#x2F; 四周新的纵坐标</span><br><span class="line">                            int ty &#x3D; y + dy[k];</span><br><span class="line">                            &#x2F;&#x2F; 不越界并且为陆地则入队</span><br><span class="line">                            if(tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; grid[tx][ty] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                                queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                                &#x2F;&#x2F; 访问过则置为&#39;0&#39;</span><br><span class="line">                                grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420100042839.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>将陆地视为无向图，相邻的1之前视为边，每次对四周进行dfs搜索，岛屿的数量即是dfs搜索的次数</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有陆地岛屿数为0</span><br><span class="line">        if(grid.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 岛屿数目</span><br><span class="line">        int islandCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找到一个陆地</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    islandCount++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandCount;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(char[][] grid, int tx, int ty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行</span><br><span class="line">        int m &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列</span><br><span class="line">        int n &#x3D; grid[0].length;</span><br><span class="line">        &#x2F;&#x2F; 越界或者已访问跳出递归</span><br><span class="line">        if(tx &lt; 0 || tx &gt;&#x3D; m || ty &lt; 0 || ty &gt;&#x3D; n || grid[tx][ty] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 访问过注意置&#39;0&#39;</span><br><span class="line">        grid[tx][ty] &#x3D; &#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F; 上</span><br><span class="line">        dfs(grid, tx + 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 下</span><br><span class="line">        dfs(grid, tx - 1, ty);</span><br><span class="line">        &#x2F;&#x2F; 左</span><br><span class="line">        dfs(grid, tx, ty - 1);</span><br><span class="line">        &#x2F;&#x2F; 右</span><br><span class="line">        dfs(grid, tx, ty + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/20200420103029306.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/number-of-islands&lt;/a&gt; 】&lt;br&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;11110&lt;br&gt;11010&lt;br&gt;11000&lt;br&gt;00000&lt;br&gt;输出: 1&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;11000&lt;br&gt;11000&lt;br&gt;00100&lt;br&gt;00011&lt;br&gt;输出: 3&lt;br&gt;解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://kawhiz.github.io/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-19T03:02:16.000Z</published>
    <updated>2020-04-19T03:14:11.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a> 】<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>图中可以很直观看到需要求解最大的矩形面积，只要找到所有情况用底乘两端较小的高再求最大值即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 直接暴力查找所有情况</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419111107235.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p><strong>问题的关键在于当底不断缩小时，如果要使面积变大，只能尽可能取到更大的高，那么初始底最大，从两端慢慢找到一个高更大的（即两端小的那端移动来找更大的高）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        &#x2F;&#x2F; 头</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 尾</span><br><span class="line">        int j &#x3D; height.length - 1;</span><br><span class="line">        &#x2F;&#x2F; 最大面积</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            &#x2F;&#x2F; 算出围成矩形的最大面积</span><br><span class="line">            maxArea &#x3D; Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            &#x2F;&#x2F; 移动较小尽量确保高更大</span><br><span class="line">            if(height[i] &lt;&#x3D; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110353562.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water&lt;/a&gt; 】&lt;br&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;&lt;img src=&quot;/2020/04/19/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/20200419110501273.png&quot; alt&gt;&lt;br&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;br&gt;输出：49&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-17T06:38:05.000Z</published>
    <updated>2020-04-17T08:07:43.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a> 】<br>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>我一开始的思路不是超时就是用例通过率只有70%。。。<br>所以参照了贪心算法的几种思路，有几个关键：<br>（1）如果考虑某个位置可达？只要最大跳跃长度不小于最后一个位置即可，即i + nums[i] &gt;= nums.length - 1<br>（2）从左往右开始判断还是从右往左判断？分别怎样处理？</strong></p><h1 id="三种方案"><a href="#三种方案" class="headerlink" title="三种方案"></a>三种方案</h1><p><strong>从右往左遍历最近的可达则舍去最后一个</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当前位置距离最后一个可达的最小长度</span><br><span class="line">    int curMin &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二个开始往左遍历判断是否可达最后一个</span><br><span class="line">    for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前位置可达，视为舍弃最后一个</span><br><span class="line">        if (nums[i] &gt;&#x3D; curMin) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意置一</span><br><span class="line">            curMin &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; 不可达代表当前位置左边一个位置距离最后一个可达的最小长度变长一单位</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curMin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 为一代表每次判断都可达</span><br><span class="line">    return curMin &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417035810776.png" alt></p><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2><p><strong>从左往右只要下一个位置可达每次更新最大跳跃距离， 只要有任意一个位置可达则代表可达，遍历完代表不可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 目前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 从头遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 下一个位置可跳跃达到，更新当前最大跳跃距离</span><br><span class="line">            if (i &lt;&#x3D; curMax) &#123;</span><br><span class="line">                curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">                &#x2F;&#x2F; 如果可以当前可跳跃最大距离大于最后的位置即可跳跃到达</span><br><span class="line">                if (i + nums[i] &gt;&#x3D; n - 1) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040013206.png" alt></p><h2 id="方案III"><a href="#方案III" class="headerlink" title="方案III"></a>方案III</h2><p><strong>从左往右跳跃，每次也是更新最大跳跃距离，不过同II不同的是，不可达的判断是最大跳跃距离位置左边都是可跳跃区域，右边跳不到，遍历完代表可达</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前最大跳跃距离</span><br><span class="line">        int curMax &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从左往右跳的话，最大跳跃距离位置左边都是可跳跃区域，右边跳不到</span><br><span class="line">            if(i &gt; curMax) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 更新最大跳跃距离</span><br><span class="line">            curMax &#x3D; Math.max(curMax, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/17/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/20200417040224491.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/jump-game&lt;/a&gt; 】&lt;br&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;br&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;br&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [2,3,1,1,4]&lt;br&gt;输出: true&lt;br&gt;解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [3,2,1,0,4]&lt;br&gt;输出: false&lt;br&gt;解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>01矩阵</title>
    <link href="https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/"/>
    <id>https://kawhiz.github.io/2020/04/15/01%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-15T06:22:12.000Z</published>
    <updated>2020-04-15T06:42:27.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/01-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/01-matrix</a> 】</p><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p><p>示例 1:<br>输入:<br>0 0 0<br>0 1 0<br>0 0 0<br>输出:<br>0 0 0<br>0 1 0<br>0 0 0</p><p>示例 2:<br>输入:<br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br>0 0 0<br>0 1 0<br>1 2 1</p><p>注意:<br>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>需要搜索邻近方向可以考虑用bfs搜索来解决，这里0、1都是不定的，按照多源bfs的一般思路来<br>有几个关键问题：<br>（1）队列里面先放什么？入队条件是什么？一开始尝试先将所有的1入队，然后向四周找到一个最近的0去计算距离，不过这样很难处理最近距离以及考虑入队条件，后来考虑将所有0先入队，设置该位置已经访问过，那么问题一下子迎刃而解<br>（2）最近距离如何计算？向四周查找时目标位置的距离每次都是初始距离 + 1，特别注意越界问题以及访问过的位置不要重复累加和入队</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列存放为0的元素当前横坐标、纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Queue&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 横坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;-1, 1, 0, 0&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 纵坐标变化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    public int[][] updateMatrix(int[][] matrix) &#123;</span><br><span class="line">        int m &#x3D; matrix.length;</span><br><span class="line">        int n &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int[][] res &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 每个结点是否访问</span><br><span class="line">        boolean[][] used &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 将所有0入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] point &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 横坐标</span><br><span class="line">            int x &#x3D; point[0];</span><br><span class="line">            &#x2F;&#x2F; 纵坐标</span><br><span class="line">            int y &#x3D; point[1];</span><br><span class="line">            for (int k &#x3D; 0; k &lt; dx.length; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向横坐标</span><br><span class="line">                int tx &#x3D; x + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 当前位置四个方向纵坐标</span><br><span class="line">                int ty &#x3D; y + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界或者已经被访问则跳过, 否则累加计算计算距离0最近的距离</span><br><span class="line">                if (tx &gt;&#x3D; 0 &amp;&amp; tx &lt; m &amp;&amp; ty &gt;&#x3D; 0 &amp;&amp; ty &lt; n &amp;&amp; !used[tx][ty]) &#123;</span><br><span class="line">                    res[tx][ty] &#x3D; res[x][y] + 1;</span><br><span class="line">                    &#x2F;&#x2F; 注意设置已访问</span><br><span class="line">                    used[tx][ty] &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 继续找其他1</span><br><span class="line">                    queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/15/01%E7%9F%A9%E9%98%B5/20200415024226920.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/01-matrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/01-matrix&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;br&gt;两个相邻元素间的距离为 1 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;0 0 0&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 1 1&lt;br&gt;输出:&lt;br&gt;0 0 0&lt;br&gt;0 1 0&lt;br&gt;1 2 1&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;给定矩阵的元素个数不超过 10000。&lt;br&gt;给定矩阵中至少有一个元素是 0。&lt;br&gt;矩阵中的元素只在四个方向上相邻: 上、下、左、右。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>两数相加II</title>
    <link href="https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-04-14T06:02:23.000Z</published>
    <updated>2020-04-14T06:57:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a> 】<br>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：<br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：<br>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>平常计算两数和时都是在低位开始算起，满十进一即可，只是要注意单链表遍历的顺序跟结果是相反的，自然而然可以想到使用栈来进行逆序<br>利用三个栈，两个存放两个链表，另一个存放结果，最终逆序输出即可，几个关键<br>（1）如果两数长度不等需高位补零计算<br>（2）特别注意栈空后进制剩余仍需再计算一次</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l1 + l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack3 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 最终结果</span><br><span class="line">        ListNode res &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 最终结果的头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 值为的0结点</span><br><span class="line">        ListNode n0 &#x3D; new ListNode(0);</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while((!stack1.isEmpty()) || (!stack2.isEmpty()) || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不对齐的补零</span><br><span class="line">            if(stack1.isEmpty()) &#123;</span><br><span class="line">                stack1.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack2.isEmpty()) &#123;</span><br><span class="line">                stack2.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 加法</span><br><span class="line">            x &#x3D; (stack1.pop().val + stack2.pop().val);</span><br><span class="line">            &#x2F;&#x2F; 低位是否有进位</span><br><span class="line">            if(k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                x++;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前无进位</span><br><span class="line">            if(x &lt; 10) &#123;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 当前有进位</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                x %&#x3D; 10;</span><br><span class="line">                k &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            stack3.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 反向取出栈的结果即可</span><br><span class="line">        if(!stack3.isEmpty()) &#123;</span><br><span class="line">            head &#x3D; stack3.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意存放结果</span><br><span class="line">        res &#x3D; head;</span><br><span class="line">        while(!stack3.isEmpty()) &#123;</span><br><span class="line">            ListNode top &#x3D; stack3.pop();</span><br><span class="line">            head.next &#x3D; top;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 单链表</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414021233262.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>在栈里存放直接存放结点处理太耗时耗力，直接存放待加的值即可<br>边加边使用头插法刚好可以实现逆序，类似栈的效果，不用额外设置第三个栈来辅助判断</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 结果头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty() || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int a &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">            int b &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">            &#x2F;&#x2F; 求和、注意加上低位的进位</span><br><span class="line">            x &#x3D; a + b + k;</span><br><span class="line">            &#x2F;&#x2F; 求进制</span><br><span class="line">            k &#x3D; x &#x2F; 10;</span><br><span class="line">            &#x2F;&#x2F; 求本位</span><br><span class="line">            x %&#x3D; 10;</span><br><span class="line">            &#x2F;&#x2F; 头插法：新结点每次都插入到链表头部，刚好实现逆序</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414024711242.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p><strong>虽然一开始的思路还算比较清晰，但是由于太久没使用链表，有些地方结果还是调试了很久。。。所以还是要多加练习</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers-ii&lt;/a&gt; 】&lt;br&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;进阶：&lt;br&gt;如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：(7 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br&gt;输出：7 -&amp;gt; 8 -&amp;gt; 0 -&amp;gt; 7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实现Trie前缀树</title>
    <link href="https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/</id>
    <published>2020-04-13T04:05:11.000Z</published>
    <updated>2020-04-13T07:09:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a> 】<br>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true</p><p>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始的思路是用一个LinkedList存放，插入和查询都已实现，直接暴力查找每一个前缀子串是否匹配，缺点显而易见、如果单词非常长非常多，那么每次都要重复大量判断前缀，case通过率93%，最后一个用例超时<br>所以如果能把前缀都存储下来，每次就不需要大量重复判断，因为只有26个小写字母，所以可以使用前缀树（字典树）来存储，有以下几个关键<br>（1）每个前缀树最多有26个分支，每次拼写完一个单词需要标记拼写结束<br>（2）插入时没有后一个结点则需要新创建一个，否则继续往下一层查找<br>（3）查找前缀和查找单词区别在于是否标记单词拼写结束</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树（字典树）长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final int length &#x3D; 26;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树下个结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Trie[] next;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 单词拼写是否结束</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        next &#x3D; new Trie[length];</span><br><span class="line">        isEnd &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在前缀树中插入一个单词</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前结点下一个结点为空，则创建新的前缀树</span><br><span class="line">            if (node.next[c - &#39;a&#39;] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                node.next[c - &#39;a&#39;] &#x3D; new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 继续下一个结点判断</span><br><span class="line">            node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 每次插入完一个单词记得标记</span><br><span class="line">        node.isEnd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词前缀</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Trie searchPrefix(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到下个结点则继续找</span><br><span class="line">            if (node.next[c - &#39;a&#39;] !&#x3D; null) &#123;</span><br><span class="line">                node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">                &#x2F;&#x2F; 否则直接返回null</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(word);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到且必须为完整单词则代表找到该单词</span><br><span class="line">        return node !&#x3D; null &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找前缀是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(prefix);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到前缀则返回true</span><br><span class="line">        return node !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/20200413121411842.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree&lt;/a&gt; 】&lt;br&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;Trie trie = new Trie();&lt;br&gt;trie.insert(“apple”);&lt;br&gt;trie.search(“apple”);   // 返回 true&lt;br&gt;trie.search(“app”);     // 返回 false&lt;br&gt;trie.startsWith(“app”); // 返回 true&lt;br&gt;trie.insert(“app”);&lt;br&gt;trie.search(“app”);     // 返回 true&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;br&gt;保证所有输入均为非空字符串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>分割等和子集</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2020-04-12T10:48:41.000Z</published>
    <updated>2020-04-12T11:12:20.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a> 】<br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><p>示例 1:<br>输入: [1, 5, 11, 5]</p><p>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:<br>输入: [1, 2, 3, 5]</p><p>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>这题一开始在思考如何解决还是有点棘手，怎么都没想到这是一道背包问题的变种。。。。。。<br>按照背包问题的一般思路来，这里的数类似重量，这里需要等分数组，所以数组和的一半类似总价值<br>状态dp(i,j)代表前i个数当前和j是否可等分，这里主要有加不加上第i个数两种情况<br>(1)不加上第i个数：dp(i, j) = dp(i - 1)(j)<br>(2)加上第i个数：dp(i, j) = dp(i - 1)(j - nums(i))<br>所以状态转移式dp(i, j) = (1) || (2)<br>注意考虑边界如果当前和刚好为第i个数，j = nums[i]刚好分割，那么dp(i, j)为true<br>以nums={1, 3, 4, 2}为例，具体过程如图</strong><br><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412071203200.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int m &#x3D; nums.length;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 求数组和</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            n +&#x3D; num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 数组和不为偶数或者只有一个数则无法等分</span><br><span class="line">        if(n % 2 !&#x3D; 0 || m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意列数是数组和的一半加一，包括零的情况</span><br><span class="line">        n &#x3D; (n &gt;&gt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F; dp[i][j] 代表前i个数以及这些数的和刚好为j</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 只有一个数的情况</span><br><span class="line">        if(nums[0] &lt;&#x3D; n - 1) &#123;</span><br><span class="line">            dp[0][nums[0]] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        int i, j;</span><br><span class="line">        &#x2F;&#x2F; 从第二个数开始遍历</span><br><span class="line">        for (i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不选的情况</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">                &#x2F;&#x2F; 刚好可以等分的情况</span><br><span class="line">                if(j &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 分割后还有剩余的情况</span><br><span class="line">                if(j &gt; nums[i]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 问题的关键、状态转移式</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j] || dp[i - 1][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 只要最后一列有一个值为真直接返回true即可</span><br><span class="line">            if(dp[i][j - 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412065612121.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equal-subset-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/partition-equal-subset-sum&lt;/a&gt; 】&lt;br&gt;给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;每个数组中的元素不会超过 100&lt;br&gt;数组的大小不会超过 200&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [1, 5, 11, 5]&lt;/p&gt;
&lt;p&gt;输出: true&lt;br&gt;解释: 数组可以分割成 [1, 5, 5] 和 [11].&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [1, 2, 3, 5]&lt;/p&gt;
&lt;p&gt;输出: false&lt;br&gt;解释: 数组不能分割成两个元素和相等的子集.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>自定义字符串排序</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T06:37:56.000Z</published>
    <updated>2020-04-12T07:30:56.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/custom-sort-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/custom-sort-string</a> 】</p><p>字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。<br>S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。<br>返回任意一种符合条件的字符串T。</p><p>示例:<br>输入:<br>S = “cba”<br>T = “abcd”<br>输出: “cbad”<br>解释:<br>S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.<br>由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。</p><p>注意:<br>S的最大长度为26，其中没有重复的字符。<br>T的最大长度为200。<br>S和T只包含小写字符。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>既然要按照S中的字符相对顺序对T进行排序，一种直观的思路就是遍历S然后每次都遍历T，找到一个相等的则记录下来，同时记录T中该字符是否已使用，最后将T中未使用的直接加入到结果后面即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 记录T中每个字符是否使用过</span><br><span class="line">        boolean[] used &#x3D; new boolean[T.length()];</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(int i &#x3D; 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历T</span><br><span class="line">            for(int j &#x3D; 0; j &lt; T.length(); j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在T中找到一个跟S相等的则拼接起来</span><br><span class="line">                if(S.charAt(i) &#x3D;&#x3D; T.charAt(j)) &#123;</span><br><span class="line">                    sb.append(T.charAt(j));</span><br><span class="line">                    &#x2F;&#x2F; 记录已拼接</span><br><span class="line">                    used[j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res &#x3D; sb.toString();</span><br><span class="line">        &#x2F;&#x2F; 长度相等代表T中全部字符已拼接</span><br><span class="line">        if(res.length() &#x3D;&#x3D; T.length()) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 否则拼接未拼接的</span><br><span class="line">        for(int i &#x3D; 0; i &lt; used.length; i++) &#123;</span><br><span class="line">            if(!used[i]) &#123;</span><br><span class="line">                sb.append(T.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412024720133.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>前面做法每次遍历T时都要执行charAt去判断T和S的字符串是否相等，及其耗时，同时如果T的长度非常长的话，used数组也会非常占用空间，最后补充记录S中无关的字符也会非常耗时<br>因为只有26个小写字符直接使用长度26的一维数组countT记录T中每个字母出现的次数，遍历S同时将counT中出现次数不为零的字母加上，最后注意加上S中没有的字母即可</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        &#x2F;&#x2F; 自定义排序后的结果</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 存放T中&#39;a&#39; ~ &#39;z&#39;出现的次数</span><br><span class="line">        int[] countT &#x3D; new int[26];</span><br><span class="line">        &#x2F;&#x2F; 统计T中每个小写字母出现得到次数</span><br><span class="line">        for(char c : T.toCharArray()) &#123;</span><br><span class="line">            countT[c - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(char c : S.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历countT，注意判断条件i &lt; countT[c - &#39;a&#39;]写法，T中有多少个S出现的字符就添加多少次</span><br><span class="line">            for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意清零不影响后面其他S中没有的字符添加</span><br><span class="line">            countT[c - &#39;a&#39;] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 加上T剩余的原先S中没有的字母</span><br><span class="line">        for(char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;</span><br><span class="line">           for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">               res.append(c);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412032101885.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/custom-sort-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/custom-sort-string&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。&lt;br&gt;S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。&lt;br&gt;返回任意一种符合条件的字符串T。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入:&lt;br&gt;S = “cba”&lt;br&gt;T = “abcd”&lt;br&gt;输出: “cbad”&lt;br&gt;解释:&lt;br&gt;S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.&lt;br&gt;由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;S的最大长度为26，其中没有重复的字符。&lt;br&gt;T的最大长度为200。&lt;br&gt;S和T只包含小写字符。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>翻转字符串里的单词</title>
    <link href="https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2020-04-10T02:54:46.000Z</published>
    <updated>2020-04-10T03:57:07.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string</a> 】<br>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：<br>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除首位无关空格，再按空白分割成字符串数组，重新反转拼接回去<br>稍微注意java中split(“\s+”)的写法，需要加上转义字符，s+代表匹配包括空格、制表健等空白部分</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 按中间空白部分（包括空格制表键等）分割成String数组</span><br><span class="line">        String[] strArr &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        for(int i &#x3D; strArr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            sb.append(strArr[i]);</span><br><span class="line">            &#x2F;&#x2F; 统一中间加一个空格分割</span><br><span class="line">            if(i &gt; 0) &#123;</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410105915195.png" alt><br><strong>API简洁版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 通过空白部分分割</span><br><span class="line">        List&lt;String&gt; wordList &#x3D; Arrays.asList(s.split(&quot;\\s+&quot;));</span><br><span class="line">        &#x2F;&#x2F; 反转</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        &#x2F;&#x2F; 重新以单空格拼接回去</span><br><span class="line">        return String.join(&quot; &quot;, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410111721079.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>尽量少使用一些API来提升速度<br>问题的关键在于需要反转同时需要找到不定数目空格分割的单词<br>从字符串尾开始遍历实现反转，设置双指针分别用来记录每个单词的首尾，找到一个则拼接原字符串的子串到结果集里，注意中间统一按一个空格分割</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; i用来记录单词的首字符下标</span><br><span class="line">        int i &#x3D; s.length() - 1;</span><br><span class="line">        &#x2F;&#x2F; j用来记录单词的末字符下标</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 从原字符串尾部开始遍历整个字符串实现反转</span><br><span class="line">        while(i &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到最后一个单词第一个空格分割符</span><br><span class="line">            while(i &gt;&#x3D;0 &amp;&amp; s.charAt(i) !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意substring方法的下标和写法、记得去除最后一个多余的空格</span><br><span class="line">            if(i &gt;&#x3D; 0) &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1) + &quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 找到倒数第二个单词最后一个字符</span><br><span class="line">            while(i &gt;&#x3D; 0 &amp;&amp; s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加完重新更新</span><br><span class="line">            j &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410115331506.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/reverse-words-in-a-string&lt;/a&gt; 】&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入: “the sky is blue”&lt;br&gt;输出: “blue is sky the”&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入: “  hello world!  “&lt;br&gt;输出: “world! hello”&lt;br&gt;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入: “a good   example”&lt;br&gt;输出: “example good a”&lt;br&gt;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;无空格字符构成一个单词。&lt;br&gt;输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;br&gt;如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>括号生成</title>
    <link href="https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2020-04-09T03:33:19.000Z</published>
    <updated>2020-04-09T04:30:18.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a> 】<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>因为是要生成所有可能的有效括号，类似全排列，自然而然想到用dfs递归搜索<br>n对括号的话，从根节点空字符串开始，一直到搜索到深度2n则记录其中一种情况<br>这里递归参数设为左右括号剩余量，以及当前字符串，递归条件通过有效括号匹配规则剪枝、递归出口就是当左右括号都没有剩余<br><em>问题的关键在于分析以下几种情况</em><br>左右括号都没有剩余，则到底，记录其中一种有效结果<br>左子树生成前提是左括号有剩余<br>右子树生成前提是右括号有剩余，并且要左括号剩余比右括号少才会匹配成功</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回空</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; dfs搜索根结点为&quot;&quot;</span><br><span class="line">        dfs(n, n, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; left代表剩余左括号数目，right代表剩余右括号数目，String每次都创建一个新对象回溯时不需要恢复现场</span><br><span class="line">    public void dfs(int left, int right, String curStr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左右括号都不剩余代表深度到底，加入结果集</span><br><span class="line">        if(left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左括号剩余则生成左枝</span><br><span class="line">        if(left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr + &quot;(&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右括号剩余，且左括号剩余数目必须小于右括号才有可能匹配有效</span><br><span class="line">        if(right &gt; 0 &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/20200409120632596.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/generate-parentheses&lt;/a&gt; 】&lt;br&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：n = 3&lt;br&gt;输出：[&lt;br&gt;       “((()))”,&lt;br&gt;       “(()())”,&lt;br&gt;       “(())()”,&lt;br&gt;       “()(())”,&lt;br&gt;       “()()()”&lt;br&gt;     ]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
