<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kawhiz.github.io/"/>
  <updated>2020-04-07T02:55:12.754Z</updated>
  <id>https://kawhiz.github.io/</id>
  
  <author>
    <name>庄健彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重装系统后的hexo恢复</title>
    <link href="https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/"/>
    <id>https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/</id>
    <published>2020-04-07T02:18:44.000Z</published>
    <updated>2020-04-07T02:55:12.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>win10重装系统后hexo博客如何恢复？</strong></p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="重装nodejs、git"><a href="#重装nodejs、git" class="headerlink" title="重装nodejs、git"></a>重装nodejs、git</h2><p><strong>去官网下载LTS版本</strong><br>node：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a><br>git：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a></p><h2 id="重装hexo-cli"><a href="#重装hexo-cli" class="headerlink" title="重装hexo-cli"></a>重装hexo-cli</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-cli -g</code></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103533188.png" alt></p><h2 id="保留删除文件"><a href="#保留删除文件" class="headerlink" title="保留删除文件"></a>保留删除文件</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103959930.png" alt></p><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407104150066.png" alt></p><h2 id="安装部署依赖"><a href="#安装部署依赖" class="headerlink" title="安装部署依赖"></a>安装部署依赖</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-deployer-git --save</code></p><h2 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h2><p><strong>执行完去看看是否推送成功</strong><br><code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;win10重装系统后hexo博客如何恢复？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://kawhiz.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-06T08:52:43.000Z</published>
    <updated>2020-04-06T09:47:36.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a> 】<br>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p>示例 2：<br>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>题目给了三种操作，直观发现对A（B）插入等价于对B（A）删除、对A替换等价于对B替换，操作的顺序不影响结果<br>一开始的直观想法采用BFS搜索每种操作的情况，但是考虑可能会及其耗时<br>由于是要找最优解，若问题含有最优子结构性质可以考虑使用动态规划来解决<br>设置一个二维数组dp(i)(j)代表代表A中前i个字母转换为B中前j个字母的最少操作次数<br>dp（i，j）问题的关键在于考虑d（i - 1， j）【d（i， j - 1）】只要再执行一次插入【删除】操作子问题和dp（i - 1， j - 1)是否需要再执行一次替换操作两者的最小值<br>拿A = “horse”和B = “ros”示例，过程如图</strong><br><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406054735596.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加一是为了判断空字符串的情况</span><br><span class="line">        int m &#x3D; word1.length() + 1;</span><br><span class="line">        int n &#x3D; word2.length() + 1;</span><br><span class="line">        &#x2F;&#x2F; 存放A中前m个和B中前n个字母得的少操作次数</span><br><span class="line">        int[][] dp &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 直观看到，如果其中一个为空字符串，那么操作次数取决于另一个的长度</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 同上</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断A、B中最后一个字符串是否相等</span><br><span class="line">                char ci &#x3D; word1.charAt(i - 1);</span><br><span class="line">                char cj &#x3D; word2.charAt(j - 1);</span><br><span class="line">                &#x2F;&#x2F; 若相等代表A、B在替换操作时跟其去除当前最后一个字母的情况相等</span><br><span class="line">                if(ci &#x3D;&#x3D; cj) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1]);</span><br><span class="line">                    &#x2F;&#x2F; 区别在于比较的最后一项多了加一（次操作）</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406045859234.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>求最优解一开始没往dp方向想，走了很多弯路。。。。。。</li><li>在分析好最优子结构和状态后，写完状态转化方程后，稍微考虑一下边界问题，很快就能编码解决问题，所以在动手之前还是要把问题分析清楚</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/edit-distance&lt;/a&gt; 】&lt;br&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;br&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：word1 = “horse”, word2 = “ros”&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;horse -&amp;gt; rorse (将 ‘h’ 替换为 ‘r’)&lt;br&gt;rorse -&amp;gt; rose (删除 ‘r’)&lt;br&gt;rose -&amp;gt; ros (删除 ‘e’)&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：word1 = “intention”, word2 = “execution”&lt;br&gt;输出：5&lt;br&gt;解释：&lt;br&gt;intention -&amp;gt; inention (删除 ‘t’)&lt;br&gt;inention -&amp;gt; enention (将 ‘i’ 替换为 ‘e’)&lt;br&gt;enention -&amp;gt; exention (将 ‘n’ 替换为 ‘x’)&lt;br&gt;exention -&amp;gt; exection (将 ‘n’ 替换为 ‘c’)&lt;br&gt;exection -&amp;gt; execution (插入 ‘u’)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-05T14:41:05.000Z</published>
    <updated>2020-04-05T14:56:51.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a> 】<br>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:<br>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>实现LRU的话关键在于如何判断移除哪个键值是最近最少未使用的，直观思路就是设置上次使用的时间戳以及使用次数<br>不过自己代码封装及其丑陋。。。<br>所以还是参考官方使用java已经封装得非常好看的LinkedHashMap，因为底层通过封装哈希表和双向链表保证了有序插入，同时实现了removeEldestEntry方法，这里cache容量满了的话要删除头部结点就是最近最少未使用的结点</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; cache的容量</span><br><span class="line">    private int capacity;</span><br><span class="line">    &#x2F;&#x2F; super(capacity, 0.75F, true)这里三个参数分别是容量、负载因子和模式，默认为插入模式存储，这里设置为访问模式存储</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        super(capacity, 0.75F, true);</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; super.getOrDefault(key, -1)这里如果查不到则返回默认值-1</span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        return super.getOrDefault(key, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        super.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果当前大小大于容量则需要移除最近最少使用的结点</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj &#x3D; new LRUCache(capacity);</span><br><span class="line"> * int param_1 &#x3D; obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/20200405105618555.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/lru-cache&lt;/a&gt; 】&lt;br&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;p&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );&lt;/p&gt;
&lt;p&gt;cache.put(1, 1);&lt;br&gt;cache.put(2, 2);&lt;br&gt;cache.get(1);       // 返回  1&lt;br&gt;cache.put(3, 3);    // 该操作会使得密钥 2 作废&lt;br&gt;cache.get(2);       // 返回 -1 (未找到)&lt;br&gt;cache.put(4, 4);    // 该操作会使得密钥 1 作废&lt;br&gt;cache.get(1);       // 返回 -1 (未找到)&lt;br&gt;cache.get(3);       // 返回  3&lt;br&gt;cache.get(4);       // 返回  4&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-04-04T03:31:37.000Z</published>
    <updated>2020-04-04T06:09:02.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a> 】<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png" alt><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>看图可以直观发现每一个柱子高度接水量跟左右两边柱子的最大高度相关<br>当前柱子接水量等于左右两边最大高度中的最小值减去当前高度<br>这里直接简单粗暴两边遍历算出各自最大值再拿最小值来计算最后累加每一个柱子接水量即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前高度左边的最大值</span><br><span class="line">        int maxLeft &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 当前高度右边的最大值</span><br><span class="line">        int maxRight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 一个往右一个往左、注意边界判断即可</span><br><span class="line">            int j &#x3D; i + 1, k &#x3D; i - 1;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往右查找右边最大高度</span><br><span class="line">            while(j &lt; n) &#123;</span><br><span class="line">                maxRight &#x3D; Math.max(height[j], maxRight);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往左查找左边最大高度</span><br><span class="line">            while(k &gt; -1) &#123;</span><br><span class="line">                maxLeft &#x3D; Math.max(height[k], maxLeft);</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量     </span><br><span class="line">            int temp &#x3D; (Math.min(maxRight, maxLeft) - height[i]);</span><br><span class="line">            if(temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意重新归零</span><br><span class="line">            maxRight &#x3D; 0;</span><br><span class="line">            maxLeft &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404114109687.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路I"><a href="#思路I" class="headerlink" title="思路I"></a>思路I</h2><p><strong>可以额外开数组记录中间结果而不用每次都在循环内再循环遍历左右最大值，拿极小的空间代价换取时间</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 分别存放i左右两边的最大值</span><br><span class="line">        int[] maxLeft &#x3D; new int[n];</span><br><span class="line">        int[] maxRight &#x3D; new int[n];</span><br><span class="line">        &#x2F;&#x2F; 最左边的左边以及最右边的右边最大值都为0</span><br><span class="line">        maxLeft[0] &#x3D; 0;</span><br><span class="line">        maxRight[n - 1] &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 记录i左边的最大值</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            maxLeft[i] &#x3D; Math.max(height[i - 1], maxLeft[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录i右边的最大值</span><br><span class="line">        for (int i &#x3D; n - 2; i &gt; 0; i--) &#123;</span><br><span class="line">            maxRight[i] &#x3D; Math.max(height[i + 1], maxRight[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量</span><br><span class="line">            int temp &#x3D; (Math.min(maxRight[i], maxLeft[i]) - height[i]);</span><br><span class="line">            if (temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404015530001.png" alt></p><h2 id="思路II"><a href="#思路II" class="headerlink" title="思路II"></a>思路II</h2><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt; 】&lt;br&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;&lt;img src=&quot;/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png&quot; alt&gt;&lt;br&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;输出: 6&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字符串转换整数atoi</title>
    <link href="https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/"/>
    <id>https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/</id>
    <published>2020-04-03T07:30:08.000Z</published>
    <updated>2020-04-03T07:53:29.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a> 】<br>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:<br>输入: “42”<br>输出: 42</p><p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除多余的空格然后记录正负号，千万注意对Integer越界情况进行判断<br>问题的关键在于res = res * 10 + num &gt; Integer.MAX_VALUE这里计算出来的结果可能越界所以必须先判断再计算最后根据正负号对应添加符号<br>int num = c - ‘0’;这里通过ASCII计算可以将char c转化为对应的int</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去前面和后面多余的空格</span><br><span class="line">        str &#x3D; str.trim();</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回无效</span><br><span class="line">        if(&quot;&quot;.equals(str)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否负数</span><br><span class="line">        boolean isNegative &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 字符串下标</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        char c &#x3D; str.charAt(i);</span><br><span class="line">        &#x2F;&#x2F; 遇到负号</span><br><span class="line">        if(c &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            isNegative &#x3D; true;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到正号</span><br><span class="line">        &#125; else if(c &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到无效数字</span><br><span class="line">        &#125; else if(!Character.isDigit(c)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 遇到0 ~ 9</span><br><span class="line">        while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i))) &#123;</span><br><span class="line">            c &#x3D; str.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 将字符转化为int</span><br><span class="line">            int num &#x3D; c - &#39;0&#39;;</span><br><span class="line">            &#x2F;&#x2F; 当res * 10 + num &gt; Integer.MAX_VALUE越界、所以先判断res的范围</span><br><span class="line">            if (res &gt; (Integer.MAX_VALUE - num) &#x2F; 10) &#123;</span><br><span class="line">                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不越界则正常加</span><br><span class="line">            res &#x3D; res * 10 + num;</span><br><span class="line">            &#x2F;&#x2F; 判断下一个</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return isNegative ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/20200403033744892.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>我一开始考虑使用一个StringBuffer来接受结果但是判断越界的时候又需要重新转化非常麻烦所以用int来接受结果是比较好的</li><li>我一开始自己写了去除空格的判断以及是否为数字的判断导致代码非常臃肿难看低效，因此这里都用String.trim()、Character.isDigit()这些库函数代替</li><li>稍微注意一下下标越界问题**</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/string-to-integer-atoi&lt;/a&gt; 】&lt;br&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;br&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：&lt;br&gt;如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。&lt;br&gt;假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。&lt;br&gt;该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。&lt;br&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。&lt;br&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0 。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;本题中的空白字符只包括空格字符 ‘ ‘ 。&lt;br&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “42”&lt;br&gt;输出: 42&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: “   -42”&lt;br&gt;输出: -42&lt;br&gt;解释: 第一个非空白字符为 ‘-‘, 它是一个负号。&lt;br&gt;     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;输入: “4193 with words”&lt;br&gt;输出: 4193&lt;br&gt;解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。&lt;/p&gt;
&lt;p&gt;示例 4:&lt;br&gt;输入: “words and 987”&lt;br&gt;输出: 0&lt;br&gt;解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。&lt;br&gt;     因此无法执行有效的转换。&lt;/p&gt;
&lt;p&gt;示例 5:&lt;br&gt;输入: “-91283472332”&lt;br&gt;输出: -2147483648&lt;br&gt;解释: 数字 “-91283472332” 超过 32 位有符号整数范围。&lt;br&gt;     因此返回 INT_MIN (−231) 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>生命游戏</title>
    <link href="https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-02T11:13:46.000Z</published>
    <updated>2020-04-02T12:38:43.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/game-of-life" target="_blank" rel="noopener">https://leetcode-cn.com/problems/game-of-life</a> 】<br>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：<br>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]<br>进阶：<br>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。<br>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>可以考虑采用bfs搜索，备份原来的状态<br>直接简单粗暴将死细胞和活细胞分别入队然后各自判断周围8个位置活细胞的数目再根据规则修改状态即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 待处理的活细胞或者死细胞、队列存放数组，数组第一位存值，第二位存行数、第三位存列数</span><br><span class="line">    LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;&#x2F; 存放最终结果</span><br><span class="line">    int[][] res;</span><br><span class="line">    &#x2F;&#x2F; 8个方向数组</span><br><span class="line">    int[] dx &#x3D; &#123;-1, -1, -1, 0, 0, 1, 1, 1&#125;;</span><br><span class="line">    int[] dy &#x3D; &#123;-1, 0, 1, -1, 1, -1, 0, 1&#125;;</span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        res &#x3D; new int[board.length][board[0].length];</span><br><span class="line">        &#x2F;&#x2F; 活细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 1);</span><br><span class="line">        &#x2F;&#x2F; 死细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 0);</span><br><span class="line">        &#x2F;&#x2F; 将结果数组复制回原数组</span><br><span class="line">        for(int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;board[0].length; j++) &#123;</span><br><span class="line">                board[i][j] &#x3D; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; bfs搜索</span><br><span class="line">    public void bfs(int[][] board, int flag) &#123;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] node &#x3D; queue.poll();</span><br><span class="line">            int val &#x3D; node[0];</span><br><span class="line">            int i &#x3D; node[1];</span><br><span class="line">            int j &#x3D; node[2];</span><br><span class="line">            int count1 &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F; 统计旁边八个位置的活细胞数目</span><br><span class="line">            for (int k &#x3D; 0; k &lt; 8; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 横坐标</span><br><span class="line">                int tx &#x3D; i + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 纵坐标</span><br><span class="line">                int ty &#x3D; j + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界则跳过</span><br><span class="line">                if (tx &lt; 0 || tx &gt;&#x3D; board.length || ty &lt; 0 || ty &gt;&#x3D; board[0].length) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[tx][ty] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 活细胞周围细胞数小于2或者大于3死亡、等于2或者等于3仍然存活；</span><br><span class="line">            if (flag &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                if (count1 &lt; 2 || count1 &gt; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 2 || count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 死细胞周围有三个活细胞则复活</span><br><span class="line">            if (flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意活细胞数清零</span><br><span class="line">            count1 &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402072054309.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>因为额外开数组和各自判断对速度和内存影响极大，但是为了同时记录活细胞和死细胞当下和先前的状态从而不影响活细胞数目判断，可以考虑自己设置其他状态码<br>这里用-1代表从活细胞到死细胞、2代表从死细胞到活细胞，最后处理完注意更新新状态<br>8个位置的横纵坐标变化只有1，0，-1，但是要注意排除0，0（自身）的情况</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从活细胞到死细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int liveToDead &#x3D; -1;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从死细胞到活细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int deadToLive &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 3个坐标值变化数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int[] change &#x3D; &#123;0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行数</span><br><span class="line">        int m &#x3D; board.length;</span><br><span class="line">        &#x2F;&#x2F; 列数</span><br><span class="line">        int n &#x3D; board[0].length;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 开始从第一个细胞遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 周围8个位置活细胞数目</span><br><span class="line">                int countLive &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 对每个细胞周围8个方向判断</span><br><span class="line">                for (int k &#x3D; 0; k &lt; change.length; k++) &#123;</span><br><span class="line">                    for (int l &#x3D; 0; l &lt; change.length; l++) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 排除当前细胞自身</span><br><span class="line">                        if (change[k] !&#x3D; 0 || change[l] !&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 周围位置横坐标</span><br><span class="line">                            int x &#x3D; (i + change[k]);</span><br><span class="line">                            &#x2F;&#x2F; 周围位置纵坐标</span><br><span class="line">                            int y &#x3D; (j + change[l]);</span><br><span class="line">                            &#x2F;&#x2F; 不越界的情况下周围是否有活细胞、注意判断要包括活细胞到死细胞这种情况</span><br><span class="line">                            boolean hasLiveCell &#x3D; (x &gt;&#x3D; 0 &amp;&amp; x &lt; m) &amp;&amp; (y &gt;&#x3D; 0 &amp;&amp; y &lt; n) &amp;&amp; (board[x][y] &#x3D;&#x3D; 1 || board[x][y] &#x3D;&#x3D; liveToDead);</span><br><span class="line">                            if (hasLiveCell) &#123;</span><br><span class="line">                                countLive++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 活细胞到死细胞</span><br><span class="line">                if (countLive &lt; 2 || countLive &gt; 3) &#123;</span><br><span class="line">                    if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        board[i][j] &#x3D; liveToDead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 死细胞到活细胞</span><br><span class="line">                if (countLive &#x3D;&#x3D; 3 &amp;&amp; board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    board[i][j] &#x3D; deadToLive;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取更新后的状态</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; liveToDead) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; deadToLive) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402083733078.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/game-of-life&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/game-of-life&lt;/a&gt; 】&lt;br&gt;根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。&lt;/p&gt;
&lt;p&gt;给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：&lt;/p&gt;
&lt;p&gt;如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；&lt;br&gt;如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；&lt;br&gt;如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；&lt;br&gt;如果死细胞周围正好有三个活细胞，则该位置死细胞复活；&lt;br&gt;根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;[&lt;br&gt;  [0,1,0],&lt;br&gt;  [0,0,1],&lt;br&gt;  [1,1,1],&lt;br&gt;  [0,0,0]&lt;br&gt;]&lt;br&gt;输出：&lt;br&gt;[&lt;br&gt;  [0,0,0],&lt;br&gt;  [1,0,1],&lt;br&gt;  [0,1,1],&lt;br&gt;  [0,1,0]&lt;br&gt;]&lt;br&gt;进阶：&lt;br&gt;你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。&lt;br&gt;本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-04-01T08:32:31.000Z</published>
    <updated>2020-04-01T09:41:39.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a> 】<br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>左右括号必须一一匹配，可以考虑使用栈辅助存放所有左括号然后遇到一个右括号弹出栈顶元素判断是否匹配，最后栈空代表一一匹配成功<br>惯性思维考虑map的key存放左括号、value存放右括号，这样让左括号入栈后，每次遍历到一个右括号和栈顶的元素判断是否相等比key存放右括号、value存放左括号麻烦，时间慢了2倍</strong></p><h1 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放右括号、value存放左括号</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;)&#39;, &#39;(&#39;);</span><br><span class="line">        map.put(&#39;]&#39;, &#39;[&#39;);</span><br><span class="line">        map.put(&#39;&#125;&#39;, &#39;&#123;&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 让左括号入栈</span><br><span class="line">            if(!map.containsKey(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 栈顶是左括号</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                if(top !&#x3D; map.get(c)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401043902216.png" alt></p><h1 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 辅助栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放左括号、value存放右括号、这里注意跟方案I的区别</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;(&#39;, &#39;)&#39;);</span><br><span class="line">        map.put(&#39;[&#39;, &#39;]&#39;);</span><br><span class="line">        map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);</span><br><span class="line">        &#x2F;&#x2F; 防止map.get(key)异常</span><br><span class="line">        map.put(&#39;X&#39;, &#39;X&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 左括号入栈、这里注意跟方案I的区别</span><br><span class="line">            if(!map.containsValue(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里注意判断栈为空代表只有单独的右括号，所以匹配失败</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                &#x2F;&#x2F; 这里注意跟方案I的区别</span><br><span class="line">                if(c !&#x3D; map.get(top)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401045523605.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/valid-parentheses&lt;/a&gt; 】&lt;br&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;br&gt;有效字符串需满足：&lt;br&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;注意空字符串可被认为是有效字符串。&lt;br&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: “()”&lt;br&gt;输出: true&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: “()[]{}”&lt;br&gt;输出: true&lt;br&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: “(]”&lt;br&gt;输出: false&lt;br&gt;示例 4:&lt;/p&gt;
&lt;p&gt;输入: “([)]”&lt;br&gt;输出: false&lt;br&gt;示例 5:&lt;/p&gt;
&lt;p&gt;输入: “{[]}”&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://kawhiz.github.io/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://kawhiz.github.io/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-01T01:23:43.000Z</published>
    <updated>2020-04-01T08:32:58.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>简单粗暴直接全部遍历一遍<br>在每一行使用二分查找<br>我这里一开始试了一下用bfs搜索解题，其实完全没必要<br>拿右上角的数作基准，目标数大往下找，目标数小往左找</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; bfs</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        if(array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[0].length &gt; 0) &#123;</span><br><span class="line">            int m &#x3D; array.length;</span><br><span class="line">            int n &#x3D; array[0].length; </span><br><span class="line">            &#x2F;&#x2F; 存放是否访问过该结点</span><br><span class="line">            boolean[][] used &#x3D; new boolean[m][n];</span><br><span class="line">            LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">            &#x2F;&#x2F; 数组中前三个数分别代表值，横坐标，纵坐标</span><br><span class="line">            queue.offer(new int[]&#123;array[0][0], 0, 0&#125;);</span><br><span class="line">            while(!queue.isEmpty()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前结点</span><br><span class="line">                int[] node &#x3D; queue.poll();</span><br><span class="line">                if(node[0] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                int i &#x3D; node[1];</span><br><span class="line">                int j &#x3D; node[2];</span><br><span class="line">                &#x2F;&#x2F; 向右搜索</span><br><span class="line">                if(i &lt; m &amp;&amp; j &lt; n - 1) &#123;</span><br><span class="line">                    if(!used[i][j + 1]) &#123;</span><br><span class="line">                        used[i][j + 1] &#x3D; true;</span><br><span class="line">                        queue.offer(new int[]&#123;array[i][j + 1], i, j + 1&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 向下搜索</span><br><span class="line">                if(i &lt; m - 1 &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                    if(!used[i + 1][j]) &#123;</span><br><span class="line">                        used[i + 1][j] &#x3D; true;</span><br><span class="line">                        queue.offer(new int[]&#123;array[i + 1][j], i + 1, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102256555.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 二分查找</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean binarySearch(int target, int[][] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每一行二分查找</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; array[0].length - 1;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int mid &#x3D; (low + high) &gt;&gt; 1;</span><br><span class="line">            if (array[i][mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (array[i][mid] &lt; target) &#123;</span><br><span class="line">                low &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102419867.png" alt></p><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        if(array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[0].length &gt; 0) &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            int j &#x3D; array[0].length - 1;</span><br><span class="line">            &#x2F;&#x2F; 拿右上角的数作基准,越界则代表找不到</span><br><span class="line">            while (i &lt; array.length &amp;&amp; j &lt; array[0].length &amp;&amp; i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (array[i][j] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                    &#x2F;&#x2F; 目标数小往左找</span><br><span class="line">                &#125; else if (array[i][j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    &#x2F;&#x2F; 目标数大往下找</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102808233.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="剑指Offer" scheme="https://kawhiz.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>单词的压缩编码</title>
    <link href="https://kawhiz.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"/>
    <id>https://kawhiz.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</id>
    <published>2020-03-28T04:41:49.000Z</published>
    <updated>2020-03-28T04:51:55.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/short-encoding-of-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/short-encoding-of-words</a> 】<br>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。<br>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。<br>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。<br>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>示例：<br>输入: words = [“time”, “me”, “bell”]<br>输出: 10<br>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p><p>提示：<br>1 &lt;= words.length &lt;= 2000<br>1 &lt;= words[i].length &lt;= 7<br>每个单词都是小写字母 。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>直观能感受到单词只要能压缩，必须含有相同的后缀，同时注意到重复单词不会影响压缩后的结果<br>可以考虑先用set去重，再对每一个单词扫描找后缀，只要一个单词的后缀包含另一个单词，那么直接去除后者即可<br>最后剩下的都是不能压缩的单词，注意还有”#”，直接累加它们各自的长度+1即找到了压缩后的最小字符串长度</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minimumLengthEncoding(String[] words) &#123;</span><br><span class="line">        &#x2F;&#x2F; 压缩编码后的最小字符串长度</span><br><span class="line">        int minCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 存放不重复的单词</span><br><span class="line">        HashSet&lt;String&gt; set &#x3D; new HashSet&lt;String&gt;(Arrays.asList(words));</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; word.length(); j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 移除相同后缀的单词，稍微注意一下substring的用法</span><br><span class="line">                &#x2F;&#x2F; substring(begin)包括begin到结尾，substring(begin, end)包括begin不包括end</span><br><span class="line">                set.remove(word.substring(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历剩下不重复后缀单词</span><br><span class="line">        for (String str : set) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意还有&quot;#&quot;,所以每次加一</span><br><span class="line">            minCount +&#x3D; str.length() + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return minCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/20200328124416459.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/short-encoding-of-words&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/short-encoding-of-words&lt;/a&gt; 】&lt;br&gt;给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。&lt;br&gt;例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。&lt;br&gt;对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。&lt;br&gt;那么成功对给定单词列表进行编码的最小字符串长度是多少呢？&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入: words = [“time”, “me”, “bell”]&lt;br&gt;输出: 10&lt;br&gt;说明: S = “time#bell#” ， indexes = [0, 2, 5] 。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= words.length &amp;lt;= 2000&lt;br&gt;1 &amp;lt;= words[i].length &amp;lt;= 7&lt;br&gt;每个单词都是小写字母 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>卡牌分组</title>
    <link href="https://kawhiz.github.io/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/"/>
    <id>https://kawhiz.github.io/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</id>
    <published>2020-03-27T04:16:12.000Z</published>
    <updated>2020-03-27T04:25:46.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards</a> 】<br>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。</p><p>示例 1：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p><p>示例 2：<br>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p><p>示例 3：<br>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。</p><p>示例 4：<br>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]</p><p>示例 5：<br>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]</p><p>提示：<br>1 &lt;= deck.length &lt;= 10000<br>0 &lt;= deck[i] &lt; 10000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>首先考虑使用一维数组存放出现的次数<br>只要有出现次数为1的分组不成功，所有出现次数的最大公约数必须不小于2才能分组成功</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasGroupsSizeX(int[] deck) &#123;</span><br><span class="line">        &#x2F;&#x2F; 排序方便取最大值，同时执行速度大幅提升</span><br><span class="line">        Arrays.sort(deck);</span><br><span class="line">        &#x2F;&#x2F; 存放每个数的出现次数</span><br><span class="line">        int[] count &#x3D; new int[deck[deck.length - 1] + 1];</span><br><span class="line">        &#x2F;&#x2F; 统计每个数的出现次数</span><br><span class="line">        for(int i &#x3D; 0; i &lt; deck.length; i++) &#123;</span><br><span class="line">            count[deck[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 排序执行速度翻倍</span><br><span class="line">        Arrays.sort(count);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; count.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到一个出现次数为1则代表无法分组大于2</span><br><span class="line">            if(count[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 只要满足所有数的最大公因数不小于2则代表可以分组</span><br><span class="line">        for(int i &#x3D; 1; i &lt; count.length; i++) &#123;</span><br><span class="line">            if(count[i - 1] !&#x3D; 0 &amp;&amp; count[i] !&#x3D; 0)&#123;</span><br><span class="line">                if(gcd(count[i], count[i - 1]) &lt; 2 ) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 辗转相除法求最大公因数</span><br><span class="line">    public int gcd(int a, int b) &#123;</span><br><span class="line">        while(a % b !&#x3D; 0) &#123;</span><br><span class="line">            int temp &#x3D; a % b;</span><br><span class="line">            a &#x3D; b;</span><br><span class="line">            b &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/20200327122546123.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards&lt;/a&gt; 】&lt;br&gt;给定一副牌，每张牌上都写着一个整数。&lt;br&gt;此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：&lt;br&gt;每组都有 X 张牌。&lt;br&gt;组内所有的牌上都写着相同的整数。&lt;br&gt;仅当你可选的 X &amp;gt;= 2 时返回 true。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：[1,2,3,4,4,3,2,1]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：[1,1,1,2,2,2,3,3]&lt;br&gt;输出：false&lt;br&gt;解释：没有满足要求的分组。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入：[1]&lt;br&gt;输出：false&lt;br&gt;解释：没有满足要求的分组。&lt;/p&gt;
&lt;p&gt;示例 4：&lt;br&gt;输入：[1,1]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]&lt;/p&gt;
&lt;p&gt;示例 5：&lt;br&gt;输入：[1,1,2,2,2,2]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]，[2,2]，[2,2]&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= deck.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= deck[i] &amp;lt; 10000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>车的可用捕获量</title>
    <link href="https://kawhiz.github.io/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/</id>
    <published>2020-03-26T03:32:28.000Z</published>
    <updated>2020-03-26T04:44:13.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/available-captures-for-rook" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook</a> 】<br>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p><p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p><p>返回车能够在一次移动中捕获到的卒的数量。</p><p>【<a href="https://leetcode-cn.com/problems/available-captures-for-rook" target="_blank" rel="noopener">详见链接</a>】</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>题目本来不难解决，但是我感觉题目没有描述得足够清楚，可能有歧义<br>只要先找到白车的位置后再简单粗暴分别向东南西北四个方向找即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    *    白车位置的横坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int rx</span><br><span class="line">    &#x2F;**</span><br><span class="line">    *    白车位置的纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int ry</span><br><span class="line">    public int numRookCaptures1(char[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录白车位置</span><br><span class="line">        findRock(board);</span><br><span class="line">        &#x2F;&#x2F; 车能够在一次移动中捕获到的卒的数量</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意没法碾压过去，所以每个方向找到一个黑卒跳出即可</span><br><span class="line">        &#x2F;&#x2F;  扫描东</span><br><span class="line">        for (int j &#x3D; ry; j &lt; board.length; j++) &#123;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 南</span><br><span class="line">        for (int i &#x3D; rx; i &lt; board.length; i++) &#123;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 西</span><br><span class="line">        for (int j &#x3D; ry; j &gt; 0; j--) &#123;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 北</span><br><span class="line">        for (int i &#x3D; rx; i &gt; 0; i--) &#123;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找白车R的位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void findRock(char[][] board) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 只有一个R找到直接结束即可</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">                    rx&#x3D; i;</span><br><span class="line">                    ry&#x3D; j;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326114439690.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>可以考虑引入方向数组，存放北南东西四个方向对应的增量<br>向北走每走一步，横坐标rx - 1，ry不变，其余类似如图<br>新横坐标 = 白车横坐标 + step * 对应横坐标方向数组的值，新纵坐标类似</strong><br><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326123607548.png" alt></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int rx,ry;</span><br><span class="line">    public int numRookCaptures(char[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录白车位置</span><br><span class="line">        findRock(board);</span><br><span class="line">        &#x2F;&#x2F; 分别定义北南东西四个方向得坐标增量</span><br><span class="line">        int[] dx &#x3D; &#123;-1, 1, 0, 0&#125;;</span><br><span class="line">        int[] dy &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">        &#x2F;&#x2F; 车能够在一次移动中捕获到的卒的数量</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 北南东西四个方向依次遍历</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for(int step &#x3D; 1; ; step++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 某一方向上每一步对应坐标</span><br><span class="line">                int tx &#x3D; rx + step * dx[i];</span><br><span class="line">                int ty &#x3D; ry + step * dy[i];</span><br><span class="line">                &#x2F;&#x2F; 越界或者遇到白象跳出该方向</span><br><span class="line">                if(tx &lt; 0 || tx &gt;&#x3D; board.length || ty &lt; 0 || ty &gt;&#x3D; board.length || board[tx][ty] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 遇到黑卒则捕获</span><br><span class="line">                if(board[tx][ty] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找白车R的位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void findRock(char[][] board) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 只要一个R找到直接结束即可</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">                    rx &#x3D; i;</span><br><span class="line">                    ry &#x3D; j;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326123730207.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/available-captures-for-rook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/available-captures-for-rook&lt;/a&gt; 】&lt;br&gt;在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。&lt;/p&gt;
&lt;p&gt;车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。&lt;/p&gt;
&lt;p&gt;返回车能够在一次移动中捕获到的卒的数量。&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://leetcode-cn.com/problems/available-captures-for-rook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详见链接&lt;/a&gt;】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>三维形体的表面积</title>
    <link href="https://kawhiz.github.io/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/"/>
    <id>https://kawhiz.github.io/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-25T05:11:14.000Z</published>
    <updated>2020-03-25T05:52:00.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes</a> 】<br>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>请你返回最终形体的表面积。<br>示例 1：</p><p>输入：[[2]]<br>输出：10<br>示例 2：</p><p>输入：[[1,2],[3,4]]<br>输出：34<br>示例 3：</p><p>输入：[[1,0],[0,2]]<br>输出：16<br>示例 4：</p><p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32<br>示例 5：</p><p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p><p>提示：<br>1 &lt;= N &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>某个位置表面积S = 4 * i + 2（i是某个位置的方块个数大于0才统计,四个面乘以方块个数加上上下两个底面）容易直观推导出来<br>重叠侧面面积就是相邻方块数目最小值的两倍<br>遍历时需要分几种情况依次讨论，注意不要遗漏重复即可<br>最后将每个位置的总面积 - 相邻总侧面积即可求出总的表面积</strong><br><img src="/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/20200325013203303.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int surfaceArea ( int[][] grid)&#123;</span><br><span class="line">        &#x2F;&#x2F; 行数</span><br><span class="line">        int row &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列数</span><br><span class="line">        int column &#x3D; grid[0].length;</span><br><span class="line">        &#x2F;&#x2F; 去除上下重叠的面积</span><br><span class="line">        int SumArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 重叠的侧面积</span><br><span class="line">        int lateralArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 重叠部分面积数目</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; column; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 注意个数需要大于零才统计该位置</span><br><span class="line">                if(grid[i][j] &gt; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 单个表面积S &#x3D; 4 * n + 2（四个面乘以方块个数加上上下两个底面）</span><br><span class="line">                    SumArea +&#x3D; ((grid[i][j] &lt;&lt; 2) + 2);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 三种情况依次判断统计重叠侧面的数目</span><br><span class="line">                if (i &lt; row - 1 &amp;&amp; j &lt; column - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i][j + 1]);</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i + 1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &#x3D;&#x3D; column - 1 &amp;&amp; i &lt; row - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i + 1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; row - 1 &amp;&amp; j &lt; column - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i][j + 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lateralArea &#x3D; count &lt;&lt; 1;</span><br><span class="line">        return SumArea - lateralArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/20200325012738376.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/surface-area-of-3d-shapes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/surface-area-of-3d-shapes&lt;/a&gt; 】&lt;br&gt;在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。&lt;br&gt;每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。&lt;br&gt;请你返回最终形体的表面积。&lt;br&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：[[2]]&lt;br&gt;输出：10&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：[[1,2],[3,4]]&lt;br&gt;输出：34&lt;br&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入：[[1,0],[0,2]]&lt;br&gt;输出：16&lt;br&gt;示例 4：&lt;/p&gt;
&lt;p&gt;输入：[[1,1,1],[1,0,1],[1,1,1]]&lt;br&gt;输出：32&lt;br&gt;示例 5：&lt;/p&gt;
&lt;p&gt;输入：[[2,2,2],[2,1,2],[2,2,2]]&lt;br&gt;输出：46&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= N &amp;lt;= 50&lt;br&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 50&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>按摩师</title>
    <link href="https://kawhiz.github.io/2020/03/24/%E6%8C%89%E6%91%A9%E5%B8%88/"/>
    <id>https://kawhiz.github.io/2020/03/24/%E6%8C%89%E6%91%A9%E5%B8%88/</id>
    <published>2020-03-24T03:19:25.000Z</published>
    <updated>2020-03-24T04:18:03.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci</a> 】<br>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。<br>注意：本题相对原题稍作改动<br>示例 1：</p><p>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。<br>示例 2：</p><p>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。<br>示例 3：</p><p>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>因为是要找最优解中的最优值，一般采用动态规划算法，考虑是否有最优子结构性质（当前问题最优解可以转化成多个子问题最优解推导而来）<br>   假设dp[i]代表前i个预约最长总时长，n[i]代表第i个预约时长。比如，dp[0]代表前1个预约的最长总时长，n[2]代表第3个预约时长<br>   当第i个预约不接时，dp0[i] = dp[i - 1]，第i个预约接受时，注意不能接受相邻预约，dp1[i] = dp[i - 2] + n[i]<br>   dp[i] = max(dp0[i], dp1[i])</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int massage(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F; 存放每一步的结果，dp[i]代表前i个预约的最长总时长</span><br><span class="line">        int []dp &#x3D; new int[n];</span><br><span class="line">        &#x2F;&#x2F; 没有预约</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 预约只有一个</span><br><span class="line">        if(n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 预约两个</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        dp[1] &#x3D; Math.max(nums[0], nums[1]);</span><br><span class="line">        &#x2F;&#x2F; 预约两个以上</span><br><span class="line">        for(int i &#x3D; 2; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取第i个不接和第i个接两种情况的最大值</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/%E6%8C%89%E6%91%A9%E5%B8%88/20200324120907868.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/the-masseuse-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/the-masseuse-lcci&lt;/a&gt; 】&lt;br&gt;一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。&lt;br&gt;注意：本题相对原题稍作改动&lt;br&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入： [1,2,3,1]&lt;br&gt;输出： 4&lt;br&gt;解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入： [2,7,9,3,1]&lt;br&gt;输出： 12&lt;br&gt;解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。&lt;br&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入： [2,1,4,5,3,1,1,3]&lt;br&gt;输出： 12&lt;br&gt;解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>链表的中间结点</title>
    <link href="https://kawhiz.github.io/2020/03/23/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <id>https://kawhiz.github.io/2020/03/23/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</id>
    <published>2020-03-23T04:50:37.000Z</published>
    <updated>2020-03-23T05:43:35.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list</a> 】<br>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.<br>示例 2：</p><p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：<br>给定链表的结点数介于 1 和 100 之间。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>问题本身不难，遍历一遍单链表统计数目后再取索引为长度的一半（用移位&gt;&gt;1或者整除/2即可）即是中间结点</strong><br><em>问题在于题目描述是非空单链表是含头结点，但是特别注意leetcode这里的测试用例是不含头结点的。。。</em></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode middleNode(ListNode head) &#123;</span><br><span class="line">        ListNode tempNode &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;只需特别注意是否含头结点即可</span><br><span class="line">        int count &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 先遍历统计结点次数</span><br><span class="line">        while(tempNode.next !&#x3D; null) &#123;</span><br><span class="line">            tempNode &#x3D; tempNode.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 中间结点索引即是结点总数的一半</span><br><span class="line">        while(index &lt; count &gt;&gt; 1) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/23/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/20200323011305619.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>由于只需要取中间结点，可以考虑设置快慢指针，慢指针每次走一步、快指针每次走两步，快指针到头后慢指针刚好指向中间</strong><br><em>特别注意判断fast走到头的判断条件fast != null &amp;&amp; fast.next != null即可</em></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode middleNode(ListNode head) &#123;</span><br><span class="line">        ListNode slow &#x3D; head, fast &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F; 慢指针每次走一步、快指针每次走两步，快指针到头后慢指针刚好指向中间</span><br><span class="line">        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/23/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/20200323012848087.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/middle-of-the-linked-list&lt;/a&gt; 】&lt;br&gt;给定一个带有头结点 head 的非空单链表，返回链表的中间结点。&lt;br&gt;如果有两个中间结点，则返回第二个中间结点。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：[1,2,3,4,5]&lt;br&gt;输出：此列表中的结点 3 (序列化形式：[3,4,5])&lt;br&gt;返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。&lt;br&gt;注意，我们返回了一个 ListNode 类型的对象 ans，这样：&lt;br&gt;ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：[1,2,3,4,5,6]&lt;br&gt;输出：此列表中的结点 4 (序列化形式：[4,5,6])&lt;br&gt;由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;给定链表的结点数介于 1 和 100 之间。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使数组唯一的最小增量</title>
    <link href="https://kawhiz.github.io/2020/03/22/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/03/22/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</id>
    <published>2020-03-22T08:01:25.000Z</published>
    <updated>2020-03-22T08:47:37.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique</a> 】<br>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p><p>返回使 A 中的每个值都是唯一的最少操作次数。</p><p>示例 1:</p><p>输入：[1,2,2]<br>输出：1<br>解释：经过一次 move 操作，数组将变为 [1, 2, 3]。<br>示例 2:</p><p>输入：[3,2,1,2,1,7]<br>输出：6<br>解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。<br>提示：</p><p>0 &lt;= A.length &lt;= 40000<br>0 &lt;= A[i] &lt; 40000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>如果直接在原来数组上处理，很难有思路，但是题目有给定原数组长度和数字大小的范围后，可以使用一维整型数组count直接存放数字出现的次数<br>特别注意每次move是自增操作，所以问题的关键在于考虑count的长度，考虑在原数组A中包含40000个39999的极端情况下，count[39999] = 40000，所以move操作后需要count长度预留2倍即可<br>遍历一维数组count时判断该位置次数如果等于0、1则不需要move，不小于2时则往后找空位，找到累加两者的位置差值，移动完注意移动前的次数减一，移动后的次数加一</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minIncrementForUnique(int[] A) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放每一个数字出现次数，在考虑极端情况时，长度预留2倍刚好</span><br><span class="line">        int[] count &#x3D; new int [A.length * 2];</span><br><span class="line">        &#x2F;&#x2F; 统计每个数字出现次数</span><br><span class="line">        for(int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            count[A[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最少操作次数</span><br><span class="line">        int overallCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 开始遍历</span><br><span class="line">        for(int j &#x3D; 0; j &lt; count.length; j++) &#123;</span><br><span class="line">            for(int k &#x3D; j + 1; k &lt; count.length; ) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果数字出现次数不大于1代表不需要move，直接跳过当前数字</span><br><span class="line">                if(count[j] &lt;&#x3D; 1) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                    &#x2F;&#x2F; 需要move时往后找是否有空缺即出现次数为0的位置</span><br><span class="line">                &#125; else if(count[k] !&#x3D; 0) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    &#x2F;&#x2F; 找到一个空位</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 这里k -j 的差值就是一次move操作次数</span><br><span class="line">                    overallCount +&#x3D; k - j;</span><br><span class="line">                    &#x2F;&#x2F; 移动完注意移动前的次数减一，移动后的次数加一</span><br><span class="line">                    count[j]--;</span><br><span class="line">                    count[k]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return overallCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/22/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/20200322041555866.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p><strong>先排序然后保证后一位大于前一位，否则进行move操作</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minIncrementForUnique(int[] A) &#123;</span><br><span class="line">        &#x2F;&#x2F; 排序</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        &#x2F;&#x2F; 最少操作次数</span><br><span class="line">        int overallCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 开始遍历</span><br><span class="line">        for(int i &#x3D; 1; i &lt; A.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 后一位数比前一位数大则跳过</span><br><span class="line">            if(A[i] &gt; A[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">                &#x2F;&#x2F; 保证后一位大于前一位</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while(A[i] &lt;&#x3D; A[i - 1]) &#123;</span><br><span class="line">                    A[i] ++;</span><br><span class="line">                    overallCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return overallCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/22/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/20200322044626006.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique&lt;/a&gt; 】&lt;br&gt;给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。&lt;/p&gt;
&lt;p&gt;返回使 A 中的每个值都是唯一的最少操作次数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入：[1,2,2]&lt;br&gt;输出：1&lt;br&gt;解释：经过一次 move 操作，数组将变为 [1, 2, 3]。&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入：[3,2,1,2,1,7]&lt;br&gt;输出：6&lt;br&gt;解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。&lt;br&gt;可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。&lt;br&gt;提示：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= A.length &amp;lt;= 40000&lt;br&gt;0 &amp;lt;= A[i] &amp;lt; 40000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>水壶问题</title>
    <link href="https://kawhiz.github.io/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://kawhiz.github.io/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-21T06:21:01.000Z</published>
    <updated>2020-03-22T06:10:57.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/</a> 】<br>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p><p>你允许：</p><p>装满任意一个水壶<br>清空任意一个水壶<br>从一个水壶向另外一个水壶倒水，直到装满或者倒空<br>示例 1: (From the famous “Die Hard” example)</p><p>输入: x = 3, y = 5, z = 4<br>输出: True<br>示例 2:</p><p>输入: x = 2, y = 6, z = 5<br>输出: False</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>主要参考了官方的数学思路【链接： <a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a> 】<br>在理解完题意结合裴蜀定理后，问题的关键就是判断目标数是否可以整除两数最大公约数（这里求两数最大公约数使用效率极高的辗转相除法也就是欧几里得算法），直观可以判断这里两数之和必须不小于目标数才有可能盛放<br>需要注意题意中没有说明xyz非零、需要额外判断</strong><br><em>额外补充与本题无关的信息–两数的最小公倍数为两数乘积除以两数最大公约数：lcm(a, b) = a * b / gcd(a, b)</em></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 整数中的裴蜀定理：ax + by &#x3D; z有（无穷多个）解 &lt;&lt;&#x3D;&#x3D;&gt;&gt; z % gcd(a,b) &#x3D;&#x3D; 0</span><br><span class="line">    **&#x2F;</span><br><span class="line">    public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑x、y都为0时取决于z是否为0</span><br><span class="line">        if(x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return z &#x3D;&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; z为0则必定可以盛放</span><br><span class="line">        &#x2F;&#x2F; 直观可以判断x + y需大于等于z才有可能盛放</span><br><span class="line">        &#x2F;&#x2F; 主要取决于裴蜀定理的判断</span><br><span class="line">        return z &#x3D;&#x3D; 0 || z % gcd(x, y) &#x3D;&#x3D; 0 &amp;&amp; x + y &gt;&#x3D; z;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 辗转相除法求最大公约数gcd：两数相除，将被除数更新为除数，除数更行为两数的第一余数，直到最后余数为零则当前除数为最大公约数</span><br><span class="line">     * 注意被除数为整型时（short、int、long）会抛出java.lang.ArithmeticException: &#x2F; by zero， 被除数为整型时不可为零。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public double gcd(double x, double y) &#123;</span><br><span class="line">        double temp &#x3D; x % y;</span><br><span class="line">        while (temp !&#x3D; 0) &#123;</span><br><span class="line">            x &#x3D; y;</span><br><span class="line">            y &#x3D; temp;</span><br><span class="line">            temp &#x3D; x % y;</span><br><span class="line">        &#125;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/20200321023655497.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>由于需要遍历找到一种可行方案可以考虑使用两种常用的搜索算法DFS、BFS，因为DFS一般使用递归，不限制递归深度可能超时，所以这里使用了BFS（虽然必须记录中间访问过程可能更加耗费内存）<br>还是先直观特例判断、边界外剪枝，问题的关键在于考虑每一次都可能有8种情况与前提（见方案中的代码1~8注释）、利用一个HashSet来判断是否访问过，HashSet中的key借鉴key = curX * (Y + 1L) + curY来保证{curX,curY}的不重复</strong><br><strong><em>注意的是leetcode中如果测试通过、提交不通过情况下，然后你是Java使用了成员变量，注意不要使用static修饰符否则提交无法通过</em></strong></p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放当前水量的状态、用一个数组前两位存放数值对(curX, curY)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Queue&lt;int[]&gt; cur &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否已经被访问过</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Set&lt;Long&gt; visited &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 就是y的值、设为成员变量方便多次多处调用而不用方法间一直传值、让代码更清晰</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private int Y;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; bfs搜索</span><br><span class="line">    public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        &#x2F;&#x2F; 直观特例判断、边界外剪枝</span><br><span class="line">        if (x + y &lt; z) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (z &#x3D;&#x3D; 0 || x + y &#x3D;&#x3D; z) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 设置起点</span><br><span class="line">        cur.add(new int[]&#123;0, 0&#125;);</span><br><span class="line">        &#x2F;&#x2F; 赋值</span><br><span class="line">        Y &#x3D; y;</span><br><span class="line">        while (!cur.isEmpty()) &#123;</span><br><span class="line">            int[] curXY &#x3D; (int[]) cur.poll();</span><br><span class="line">            &#x2F;&#x2F; x升容量水壶的当前水量</span><br><span class="line">            int curX &#x3D; curXY[0];</span><br><span class="line">            &#x2F;&#x2F; y升容量水壶的当前水量</span><br><span class="line">            int curY &#x3D; curXY[1];</span><br><span class="line">            &#x2F;&#x2F; 找到一个满足目标条件直接结束即可</span><br><span class="line">            if (curX &#x3D;&#x3D; z || curY &#x3D;&#x3D; z || curX + curY &#x3D;&#x3D; z) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 8种可能倒水情况</span><br><span class="line">            &#x2F;&#x2F; 1.装满X，前提X当前水未满</span><br><span class="line">            if (curX &lt; x) &#123;</span><br><span class="line">                nextHandle(x, curY);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 2.装满Y，前提Y当前水未满</span><br><span class="line">            if (curY &lt; y) &#123;</span><br><span class="line">                nextHandle(curX, y);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 3.倒空X，前提X当前有水</span><br><span class="line">            if (curX &gt; 0) &#123;</span><br><span class="line">                nextHandle(0, curY);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 4.倒空Y，墙体T当前有水</span><br><span class="line">            if (curY &gt; 0) &#123;</span><br><span class="line">                nextHandle(curX, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 5.Y倒进X，Y有剩、X满，前提Y倒进X后仍剩水，否则跟1类似</span><br><span class="line">            if (curY - (x - curX) &gt; 0) &#123;</span><br><span class="line">                nextHandle(x, curY - (x - curX));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 6.X倒进Y，X有剩、Y满，前提X倒进Y后仍剩水，否则跟2类似</span><br><span class="line">            if (curX - (y - curY) &gt; 0) &#123;</span><br><span class="line">                nextHandle(curX - (y - curY), y);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 7.Y倒进X，Y空、X未满，前提时是Y倒进X后X未满，否则跟1类似</span><br><span class="line">            if (curX + curY &lt; x) &#123;</span><br><span class="line">                nextHandle(curX + curY, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 8.X倒进Y，X空、Y未满，前提时是X倒进Y后Y未满，否则跟2类似</span><br><span class="line">            if (curX + curY &lt; y) &#123;</span><br><span class="line">                nextHandle(0, curX + curY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 下一步操作</span><br><span class="line">    public void nextHandle(int curX, int curY) &#123;</span><br><span class="line">        &#x2F;&#x2F; 保证&#123;x,y&#125;的不重复</span><br><span class="line">        Long key &#x3D; curX * (Y + 1L) + curY;</span><br><span class="line">        if (!visited.contains(key)) &#123;</span><br><span class="line">            cur.offer(new int[]&#123;curX, curY&#125;);</span><br><span class="line">            visited.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/21/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/20200322020915116.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/water-and-jug-problem/&lt;/a&gt; 】&lt;br&gt;有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;p&gt;装满任意一个水壶&lt;br&gt;清空任意一个水壶&lt;br&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;br&gt;示例 1: (From the famous “Die Hard” example)&lt;/p&gt;
&lt;p&gt;输入: x = 3, y = 5, z = 4&lt;br&gt;输出: True&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: x = 2, y = 6, z = 5&lt;br&gt;输出: False&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最小的k个数</title>
    <link href="https://kawhiz.github.io/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>https://kawhiz.github.io/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-20T03:21:12.000Z</published>
    <updated>2020-03-20T06:01:54.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a> 】<br>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p>限制：<br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>可以常用的排序算法冒泡、直接选择、直接插入这几种，这里采用了直接选择和冒泡排序</strong><br><strong>直接使用Arrays.sort()发现速度极快。。。内存占用极少。。。</strong></p><h1 id="几种解决方案"><a href="#几种解决方案" class="headerlink" title="几种解决方案"></a>几种解决方案</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放排好序的结果数组</span><br><span class="line">        int []res &#x3D; new int [k];</span><br><span class="line">        &#x2F;&#x2F; 用来交换的临时变量</span><br><span class="line">        int temp &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 这里采用直接选择排序，每轮找到一个最小值存放数组头</span><br><span class="line">        for(int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                temp &#x3D; arr[i];</span><br><span class="line">                if(temp &gt; arr[j]) &#123;</span><br><span class="line">                    arr[i] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/20200320113038464.png" alt></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放排序结果</span><br><span class="line">        int []res &#x3D; new int [k];</span><br><span class="line">        int temp &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 这里采用冒泡排序</span><br><span class="line">        for(int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                if(arr[j - 1] &lt; arr[j]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j - 1];</span><br><span class="line">                    arr[j - 1] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i] &#x3D; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意结果的首位</span><br><span class="line">        if(k &#x3D;&#x3D; arr.length) &#123;</span><br><span class="line">            res[k - 1] &#x3D; arr[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/20200320121602616.png" alt></p><h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放排序结果</span><br><span class="line">        int[] res &#x3D; new int[k];</span><br><span class="line">        &#x2F;&#x2F; 调用排序方法</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; k; i++)&#123;</span><br><span class="line">            res[i] &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/20200320020153710.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><p><strong>改用优先队列来加快执行速度</strong><br><strong>先利用最大堆去掉不要的最大值，剩下堆中即是最小的k个数</strong></p><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放排序结果</span><br><span class="line">        int[] res &#x3D; new int[k];</span><br><span class="line">        &#x2F;&#x2F; 默认最小堆，这里改写成最大堆</span><br><span class="line">        Queue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;Integer&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        for (Integer num : arr) &#123;</span><br><span class="line">            queue.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 去掉最大堆中不要的最大值</span><br><span class="line">        while (queue.size() &gt; k) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最大堆中就是最小的k个数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k &amp;&amp; queue.size() &gt; 0; i++) &#123;</span><br><span class="line">            res[i] &#x3D; queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/20200320015110148.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&lt;/a&gt; 】&lt;br&gt;输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：arr = [3,2,1], k = 2&lt;br&gt;输出：[1,2] 或者 [2,1]&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：arr = [0,1,2,1], k = 1&lt;br&gt;输出：[0]&lt;/p&gt;
&lt;p&gt;限制：&lt;br&gt;0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= arr[i] &amp;lt;= 10000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串</title>
    <link href="https://kawhiz.github.io/2020/03/19/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://kawhiz.github.io/2020/03/19/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2020-03-19T05:49:25.000Z</published>
    <updated>2020-03-19T07:17:52.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindrome/</a> 】<br>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>假设字符串的长度不会超过 1010。</p><p>示例 1:</p><p>输入:<br>“abccccdd”</p><p>输出:<br>7</p><p>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>根据回文串的特性，正反都是对称，中间也可以包含一个</strong><br><strong><em>在统计次数后，可以很直观发现只要字母数目是偶数长度就可以直接加上去，奇数的话需要将长度减一再加上去，只要存在一个奇数或多个奇数次数也只能加一</em></strong></p><h1 id="一种解决方案"><a href="#一种解决方案" class="headerlink" title="一种解决方案"></a>一种解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestPalindrome(String s) &#123;</span><br><span class="line">        char[] c&#x3D; s.toCharArray();</span><br><span class="line">        &#x2F;&#x2F; 存放字符串中每个字母出现的次数</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 统计各个字母出现的次数</span><br><span class="line">        for(int i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">            if(!map.containsKey(c[i])) &#123;</span><br><span class="line">                map.put(c[i], ++count);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                count &#x3D; map.get(c[i]);</span><br><span class="line">                map.put(c[i], ++count);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意清除上一次的计数结果</span><br><span class="line">            count &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录是否含奇数次数的，只要包含一个奇数次数，放中间即可，总长度对应加一</span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        int maxLength &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 每个字母出现的次数</span><br><span class="line">        int tempLength &#x3D; 0;</span><br><span class="line">        for(Character ch : map.keySet()) &#123;</span><br><span class="line">            tempLength &#x3D; map.get(ch);</span><br><span class="line">            &#x2F;&#x2F; 如果偶数则直接可构成回文串，直接加上长度</span><br><span class="line">            if(tempLength % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                maxLength +&#x3D; tempLength; </span><br><span class="line">                &#x2F;&#x2F; 奇数需要在长度上减一</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxLength +&#x3D; tempLength - 1;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 只要包含一个奇数次数，可以放中间然后总长度对应加一即可</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            maxLength ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/19/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/20200319015714832.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><p><strong>一开始没考虑太多，直接使用HashMap存放占用内存太多、访问速度太慢，后来因为这里只有52个字母，所以考虑使用长度为58（而不是52，因为大小写ASCII不连续，中间有6个其他字符，如图）的一维数组存放</strong><br><strong><em>发现上一次最长回文串的结果判断过于繁琐，所以简单地推导转化了判断条件（如图）</em></strong><br><img src="/2020/03/19/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/20200319031110621.png" alt></p><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestPalindrome(String s) &#123;</span><br><span class="line">        char[] c &#x3D; s.toCharArray();</span><br><span class="line">        &#x2F;&#x2F; 注意&#39;A&#39;(65)和&#39;a&#39;(97)的ASCII码之间不止相差26而是相差32，所以中间需要多预留6个，所以总长度是58而不是52</span><br><span class="line">        int[] charCount &#x3D; new int[58];</span><br><span class="line">        &#x2F;&#x2F; 出现奇数次数的字母数目</span><br><span class="line">        int oddNumberCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 最长回文串长度</span><br><span class="line">        int overallLength &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 统计大小写字母出现次数,将&#39;A&#39;作为基准即可</span><br><span class="line">        for(int i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">            charCount[c[i] - &#39;A&#39;] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 统计出现奇数次数的字母数目</span><br><span class="line">        for(int item: charCount) &#123;</span><br><span class="line">            if(item % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                oddNumberCount ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 没有奇数次出现的字母则最长回文串长度是原来字符串总长度</span><br><span class="line">        if(oddNumberCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return s.length();</span><br><span class="line">            &#x2F;&#x2F; 否则只需将总长度减去奇数长度加一</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return s.length() - oddNumberCount + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/19/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/20200319030325369.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-palindrome/&lt;/a&gt; 】&lt;br&gt;给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。&lt;/p&gt;
&lt;p&gt;在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;假设字符串的长度不会超过 1010。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;“abccccdd”&lt;/p&gt;
&lt;p&gt;输出:&lt;br&gt;7&lt;/p&gt;
&lt;p&gt;解释:&lt;br&gt;我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>矩阵重叠</title>
    <link href="https://kawhiz.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/"/>
    <id>https://kawhiz.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T05:11:17.000Z</published>
    <updated>2020-03-18T05:36:26.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rectangle-overlap/</a> 】<br>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。<br>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。<br>给出两个矩形，判断它们是否重叠并返回结果。</p><p>示例 1：</p><p>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]<br>输出：true</p><p>示例 2：</p><p>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]<br>输出：false</p><p>提示：<br>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。<br>矩形中的所有坐标都处于 -10^9 和 10^9 之间。<br>x 轴默认指向右，y 轴默认指向上。<br>你可以仅考虑矩形是正放的情况。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始在考虑二维矩阵重叠时发现有很多种情况，而且判断的条件都非常容易混淆<br>后来重新考虑可能不重叠的情况条件比较容易判断，有上下左右四个方向的情况</strong><br><strong><em>问题的关键在于将左右等同到x轴的投影、上下成到y轴的投影，然后分别判断一维线段的临界值即可，想清楚问题后编码不难实现，如图</em></strong><br><img src="/2020/03/18/%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/20200318012650103.png" alt></p><h1 id="一种解决方案"><a href="#一种解决方案" class="headerlink" title="一种解决方案"></a>一种解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 分别判断上下左右四种不重叠的情况，题目有提及只有边、角接触也不算重叠，所以注意相等</span><br><span class="line">        if( (rec1[0] &gt;&#x3D; rec2[2]) || (rec1[2] &lt;&#x3D; rec2[0]) || (rec1[3] &lt;&#x3D; rec2[1]) || (rec1[1] &gt;&#x3D; rec2[3]) ) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/18/%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/20200318012332480.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/rectangle-overlap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rectangle-overlap/&lt;/a&gt; 】&lt;br&gt;矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。&lt;br&gt;如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。&lt;br&gt;给出两个矩形，判断它们是否重叠并返回结果。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]&lt;br&gt;输出：true&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]&lt;br&gt;输出：false&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。&lt;br&gt;矩形中的所有坐标都处于 -10^9 和 10^9 之间。&lt;br&gt;x 轴默认指向右，y 轴默认指向上。&lt;br&gt;你可以仅考虑矩形是正放的情况。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>单词拼写</title>
    <link href="https://kawhiz.github.io/2020/03/17/%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99/"/>
    <id>https://kawhiz.github.io/2020/03/17/%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99/</id>
    <published>2020-03-17T07:22:09.000Z</published>
    <updated>2020-03-17T09:06:40.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters</a> 】<br>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>示例 1：</p><p>输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”<br>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。<br>示例 2：</p><p>输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”<br>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p><p>提示：<br>1 &lt;= words.length &lt;= 1000<br>1 &lt;= words[i].length, chars.length &lt;= 100<br>所有字符串中都仅包含小写英文字母</p><a id="more"></a><h1 id="两种思路"><a href="#两种思路" class="headerlink" title="两种思路"></a>两种思路</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p><strong>因为这里只有26小写个字母，考虑使用长度为26的一维数组存放每个字母出现的次数。<br>然后只需比较待拼写的单词与字母串中字母出现次数，只要待拼写中存在一个字母出现的次数比字母串的大则表示无法拼写成功</strong></p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p><strong>直接利用HashMap存放字母出现的结果<br>然后只需判断待拼写单词中字母是否在字母串中出现或者其出现次数比字母串中的大则表示无法拼写成功</strong><br><em>由于此种方法使用了HashMap存放结果比一维数组更加占用内存，执行速度也有所下降</em></p><h1 id="两种解决方案"><a href="#两种解决方案" class="headerlink" title="两种解决方案"></a>两种解决方案</h1><h2 id="利用长度为26的一维数组存放结果"><a href="#利用长度为26的一维数组存放结果" class="headerlink" title="利用长度为26的一维数组存放结果"></a>利用长度为26的一维数组存放结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录字母串中各个字母出现次数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int[] countChar &#x3D; new int[26];</span><br><span class="line"></span><br><span class="line">    public int countCharacters(String[] words, String chars) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 记录词汇中各个字母出现次数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int[] countWord &#x3D; new int[26];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 先记录字母串字母出现次数</span><br><span class="line">        countCharacters(chars, countChar);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 单个词汇</span><br><span class="line">        String tempWord &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;掌握词汇总长度</span><br><span class="line">        int overallLength &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            tempWord &#x3D; words[i];</span><br><span class="line">            &#x2F;&#x2F; 记录词汇字母出现次数</span><br><span class="line">            countCharacters(tempWord, countWord);</span><br><span class="line">            &#x2F;&#x2F; 可以拼写加上掌握词汇长度</span><br><span class="line">            if(isOk(countChar, countWord)) &#123;</span><br><span class="line">                overallLength +&#x3D; tempWord.length();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 必须清空上一个单词的记录结果</span><br><span class="line">            countWord &#x3D; new int[26];</span><br><span class="line">        &#125;</span><br><span class="line">        return overallLength;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 比较是否能拼写成功</span><br><span class="line">     *</span><br><span class="line">     * @param countChar 字母串中字母出现次数</span><br><span class="line">     * @param countWord 待拼写单词字母出现次数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean isOk (int[] countChar, int[] countWord)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; countChar.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 发现单词中一个字母不够用则代表无法拼写成功</span><br><span class="line">            if (countWord[j] &gt; countChar[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录字符串每个字母出现的次数，可以用int[26]数组保存</span><br><span class="line">     *</span><br><span class="line">     * @param s 待统计字符串</span><br><span class="line">     * @param count 存放字母出现次数的一维数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void countCharacters (String s,int[] count)&#123;</span><br><span class="line">        char[] c &#x3D; s.toCharArray();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 用ASCII码值相减找到对应的位置计数加一</span><br><span class="line">            count[c[i] - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/17/%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99/20200317033129935.png" alt></p><p><img src="/2020/03/17/%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99/20200317033056556.png" alt></p><h2 id="直接利用HashMap存放结果"><a href="#直接利用HashMap存放结果" class="headerlink" title="直接利用HashMap存放结果"></a>直接利用HashMap存放结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int countCharacters(String[] words, String chars) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录字母串每一个字母出现的个数</span><br><span class="line">        HashMap&lt;Character, Integer&gt; countChars &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 记录单词每一个字母出现的个数</span><br><span class="line">        HashMap&lt;Character, Integer&gt; countWords &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        countString(chars, countChars);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 每一个待拼写单词</span><br><span class="line">        String tempString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 可拼写词汇的总长度</span><br><span class="line">        int overallLength &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历待拼写单词数组</span><br><span class="line">        for (int i &#x3D; 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            tempString &#x3D; words[i];</span><br><span class="line">            countString(tempString, countWords);</span><br><span class="line">            &#x2F;&#x2F; 判断是否可拼写</span><br><span class="line">            if (isOk(countChars, countWords)) &#123;</span><br><span class="line">                overallLength +&#x3D; tempString.length();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意重置上一次的结果</span><br><span class="line">            countWords &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        return overallLength;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录字符串每个字母对应出现的次数，结果存放在HashMap中</span><br><span class="line">     * @param s</span><br><span class="line">     * @param map</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void countString(String s, HashMap&lt;Character, Integer&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">        char[] c &#x3D; s.toCharArray();</span><br><span class="line"></span><br><span class="line">        Character tempChar &#x3D; null;</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">            tempChar &#x3D; c[i];</span><br><span class="line">            &#x2F;&#x2F; 原来不存在该字母则加入，从零计数</span><br><span class="line">            if (!map.containsKey(tempChar)) &#123;</span><br><span class="line">                map.put(tempChar, ++count);</span><br><span class="line">                &#x2F;&#x2F; 存在则拿到原来的计数开始计数</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                count &#x3D; map.get(tempChar);</span><br><span class="line">                map.put(tempChar, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 每处理完一个字母注意计数清零</span><br><span class="line">            count &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 比较是否能拼写成功</span><br><span class="line">     *</span><br><span class="line">     * @param chars</span><br><span class="line">     * @param word</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean isOk(HashMap&lt;Character, Integer&gt; chars, HashMap&lt;Character, Integer&gt; word) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历待拼写单词</span><br><span class="line">        for (Character c : word.keySet()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果字母串不存在或者字母串中出现的单词数目比所需的少，则表示无法拼写成功</span><br><span class="line">            if ((!chars.containsKey(c)) || (chars.get(c) &lt; word.get(c))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/17/%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99/20200317045911726.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters&lt;/a&gt; 】&lt;br&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”&lt;br&gt;输出：6&lt;br&gt;解释：&lt;br&gt;可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”&lt;br&gt;输出：10&lt;br&gt;解释：&lt;br&gt;可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= words.length &amp;lt;= 1000&lt;br&gt;1 &amp;lt;= words[i].length, chars.length &amp;lt;= 100&lt;br&gt;所有字符串中都仅包含小写英文字母&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
