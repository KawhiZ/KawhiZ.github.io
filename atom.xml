<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kawhiz.github.io/"/>
  <updated>2020-04-14T06:57:59.813Z</updated>
  <id>https://kawhiz.github.io/</id>
  
  <author>
    <name>庄健彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>两数相加II</title>
    <link href="https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://kawhiz.github.io/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-04-14T06:02:23.000Z</published>
    <updated>2020-04-14T06:57:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a> 】<br>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：<br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：<br>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>平常计算两数和时都是在低位开始算起，满十进一即可，只是要注意单链表遍历的顺序跟结果是相反的，自然而然可以想到使用栈来进行逆序<br>利用三个栈，两个存放两个链表，另一个存放结果，最终逆序输出即可，几个关键<br>（1）如果两数长度不等需高位补零计算<br>（2）特别注意栈空后进制剩余仍需再计算一次</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l1 + l2</span><br><span class="line">        Stack&lt;ListNode&gt; stack3 &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        &#x2F;&#x2F; 最终结果</span><br><span class="line">        ListNode res &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 最终结果的头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 值为的0结点</span><br><span class="line">        ListNode n0 &#x3D; new ListNode(0);</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while((!stack1.isEmpty()) || (!stack2.isEmpty()) || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不对齐的补零</span><br><span class="line">            if(stack1.isEmpty()) &#123;</span><br><span class="line">                stack1.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack2.isEmpty()) &#123;</span><br><span class="line">                stack2.push(n0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 加法</span><br><span class="line">            x &#x3D; (stack1.pop().val + stack2.pop().val);</span><br><span class="line">            &#x2F;&#x2F; 低位是否有进位</span><br><span class="line">            if(k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                x++;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前无进位</span><br><span class="line">            if(x &lt; 10) &#123;</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 当前有进位</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                x %&#x3D; 10;</span><br><span class="line">                k &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            stack3.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 反向取出栈的结果即可</span><br><span class="line">        if(!stack3.isEmpty()) &#123;</span><br><span class="line">            head &#x3D; stack3.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意存放结果</span><br><span class="line">        res &#x3D; head;</span><br><span class="line">        while(!stack3.isEmpty()) &#123;</span><br><span class="line">            ListNode top &#x3D; stack3.pop();</span><br><span class="line">            head.next &#x3D; top;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 单链表</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414021233262.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>在栈里存放直接存放结点处理太耗时耗力，直接存放待加的值即可<br>边加边使用头插法刚好可以实现逆序，类似栈的效果，不用额外设置第三个栈来辅助判断</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存放l1</span><br><span class="line">        Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 存放l2</span><br><span class="line">        Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 结果头指针</span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; l1、l2先入栈</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1 !&#x3D; null) &#123;</span><br><span class="line">                stack1.push(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 !&#x3D; null) &#123;</span><br><span class="line">                stack2.push(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 进位</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 本位</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 只要有一个位没算完或者还未进位</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty() || k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int a &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">            int b &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">            &#x2F;&#x2F; 求和、注意加上低位的进位</span><br><span class="line">            x &#x3D; a + b + k;</span><br><span class="line">            &#x2F;&#x2F; 求进制</span><br><span class="line">            k &#x3D; x &#x2F; 10;</span><br><span class="line">            &#x2F;&#x2F; 求本位</span><br><span class="line">            x %&#x3D; 10;</span><br><span class="line">            &#x2F;&#x2F; 头插法：新结点每次都插入到链表头部，刚好实现逆序</span><br><span class="line">            ListNode node &#x3D; new ListNode(x);</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/14/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/20200414024711242.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p><strong>虽然一开始的思路还算比较清晰，但是由于太久没使用链表，有些地方结果还是调试了很久。。。所以还是要多加练习</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers-ii&lt;/a&gt; 】&lt;br&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;进阶：&lt;br&gt;如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：(7 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br&gt;输出：7 -&amp;gt; 8 -&amp;gt; 0 -&amp;gt; 7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实现Trie前缀树</title>
    <link href="https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://kawhiz.github.io/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/</id>
    <published>2020-04-13T04:05:11.000Z</published>
    <updated>2020-04-13T07:09:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a> 】<br>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true</p><p>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始的思路是用一个LinkedList存放，插入和查询都已实现，直接暴力查找每一个前缀子串是否匹配，缺点显而易见、如果单词非常长非常多，那么每次都要重复大量判断前缀，case通过率93%，最后一个用例超时<br>所以如果能把前缀都存储下来，每次就不需要大量重复判断，因为只有26个小写字母，所以可以使用前缀树（字典树）来存储，有以下几个关键<br>（1）每个前缀树最多有26个分支，每次拼写完一个单词需要标记拼写结束<br>（2）插入时没有后一个结点则需要新创建一个，否则继续往下一层查找<br>（3）查找前缀和查找单词区别在于是否标记单词拼写结束</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树（字典树）长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final int length &#x3D; 26;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀树下个结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Trie[] next;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 单词拼写是否结束</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        next &#x3D; new Trie[length];</span><br><span class="line">        isEnd &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在前缀树中插入一个单词</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前结点下一个结点为空，则创建新的前缀树</span><br><span class="line">            if (node.next[c - &#39;a&#39;] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                node.next[c - &#39;a&#39;] &#x3D; new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 继续下一个结点判断</span><br><span class="line">            node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 每次插入完一个单词记得标记</span><br><span class="line">        node.isEnd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词前缀</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Trie searchPrefix(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到下个结点则继续找</span><br><span class="line">            if (node.next[c - &#39;a&#39;] !&#x3D; null) &#123;</span><br><span class="line">                node &#x3D; node.next[c - &#39;a&#39;];</span><br><span class="line">                &#x2F;&#x2F; 否则直接返回null</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单词是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(word);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到且必须为完整单词则代表找到该单词</span><br><span class="line">        return node !&#x3D; null &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找前缀是否存在</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(prefix);</span><br><span class="line">        &#x2F;&#x2F; 只要能找到前缀则返回true</span><br><span class="line">        return node !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/13/%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/20200413121411842.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree&lt;/a&gt; 】&lt;br&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;Trie trie = new Trie();&lt;br&gt;trie.insert(“apple”);&lt;br&gt;trie.search(“apple”);   // 返回 true&lt;br&gt;trie.search(“app”);     // 返回 false&lt;br&gt;trie.startsWith(“app”); // 返回 true&lt;br&gt;trie.insert(“app”);&lt;br&gt;trie.search(“app”);     // 返回 true&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;br&gt;保证所有输入均为非空字符串。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>分割等和子集</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2020-04-12T10:48:41.000Z</published>
    <updated>2020-04-12T11:12:20.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a> 】<br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><p>示例 1:<br>输入: [1, 5, 11, 5]</p><p>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:<br>输入: [1, 2, 3, 5]</p><p>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>这题一开始在思考如何解决还是有点棘手，怎么都没想到这是一道背包问题的变种。。。。。。<br>按照背包问题的一般思路来，这里的数类似重量，这里需要等分数组，所以数组和的一半类似总价值<br>状态dp(i,j)代表前i个数当前和j是否可等分，这里主要有加不加上第i个数两种情况<br>(1)不加上第i个数：dp(i, j) = dp(i - 1)(j)<br>(2)加上第i个数：dp(i, j) = dp(i - 1)(j - nums(i))<br>所以状态转移式dp(i, j) = (1) || (2)<br>注意考虑边界如果当前和刚好为第i个数，j = nums[i]刚好分割，那么dp(i, j)为true<br>以nums={1, 3, 4, 2}为例，具体过程如图</strong><br><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412071203200.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int m &#x3D; nums.length;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 求数组和</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            n +&#x3D; num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 数组和不为偶数或者只有一个数则无法等分</span><br><span class="line">        if(n % 2 !&#x3D; 0 || m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 注意列数是数组和的一半加一，包括零的情况</span><br><span class="line">        n &#x3D; (n &gt;&gt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F; dp[i][j] 代表前i个数以及这些数的和刚好为j</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F; 只有一个数的情况</span><br><span class="line">        if(nums[0] &lt;&#x3D; n - 1) &#123;</span><br><span class="line">            dp[0][nums[0]] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        int i, j;</span><br><span class="line">        &#x2F;&#x2F; 从第二个数开始遍历</span><br><span class="line">        for (i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不选的情况</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">                &#x2F;&#x2F; 刚好可以等分的情况</span><br><span class="line">                if(j &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 分割后还有剩余的情况</span><br><span class="line">                if(j &gt; nums[i]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 问题的关键、状态转移式</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j] || dp[i - 1][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 只要最后一列有一个值为真直接返回true即可</span><br><span class="line">            if(dp[i][j - 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/20200412065612121.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equal-subset-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/partition-equal-subset-sum&lt;/a&gt; 】&lt;br&gt;给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;每个数组中的元素不会超过 100&lt;br&gt;数组的大小不会超过 200&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [1, 5, 11, 5]&lt;/p&gt;
&lt;p&gt;输出: true&lt;br&gt;解释: 数组可以分割成 [1, 5, 5] 和 [11].&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: [1, 2, 3, 5]&lt;/p&gt;
&lt;p&gt;输出: false&lt;br&gt;解释: 数组不能分割成两个元素和相等的子集.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>自定义字符串排序</title>
    <link href="https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <id>https://kawhiz.github.io/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T06:37:56.000Z</published>
    <updated>2020-04-12T07:30:56.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/custom-sort-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/custom-sort-string</a> 】</p><p>字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。<br>S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。<br>返回任意一种符合条件的字符串T。</p><p>示例:<br>输入:<br>S = “cba”<br>T = “abcd”<br>输出: “cbad”<br>解释:<br>S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.<br>由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。</p><p>注意:<br>S的最大长度为26，其中没有重复的字符。<br>T的最大长度为200。<br>S和T只包含小写字符。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>既然要按照S中的字符相对顺序对T进行排序，一种直观的思路就是遍历S然后每次都遍历T，找到一个相等的则记录下来，同时记录T中该字符是否已使用，最后将T中未使用的直接加入到结果后面即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 记录T中每个字符是否使用过</span><br><span class="line">        boolean[] used &#x3D; new boolean[T.length()];</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(int i &#x3D; 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历T</span><br><span class="line">            for(int j &#x3D; 0; j &lt; T.length(); j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在T中找到一个跟S相等的则拼接起来</span><br><span class="line">                if(S.charAt(i) &#x3D;&#x3D; T.charAt(j)) &#123;</span><br><span class="line">                    sb.append(T.charAt(j));</span><br><span class="line">                    &#x2F;&#x2F; 记录已拼接</span><br><span class="line">                    used[j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res &#x3D; sb.toString();</span><br><span class="line">        &#x2F;&#x2F; 长度相等代表T中全部字符已拼接</span><br><span class="line">        if(res.length() &#x3D;&#x3D; T.length()) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 否则拼接未拼接的</span><br><span class="line">        for(int i &#x3D; 0; i &lt; used.length; i++) &#123;</span><br><span class="line">            if(!used[i]) &#123;</span><br><span class="line">                sb.append(T.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412024720133.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>前面做法每次遍历T时都要执行charAt去判断T和S的字符串是否相等，及其耗时，同时如果T的长度非常长的话，used数组也会非常占用空间，最后补充记录S中无关的字符也会非常耗时<br>因为只有26个小写字符直接使用长度26的一维数组countT记录T中每个字母出现的次数，遍历S同时将counT中出现次数不为零的字母加上，最后注意加上S中没有的字母即可</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String customSortString(String S, String T) &#123;</span><br><span class="line">        &#x2F;&#x2F; 自定义排序后的结果</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 存放T中&#39;a&#39; ~ &#39;z&#39;出现的次数</span><br><span class="line">        int[] countT &#x3D; new int[26];</span><br><span class="line">        &#x2F;&#x2F; 统计T中每个小写字母出现得到次数</span><br><span class="line">        for(char c : T.toCharArray()) &#123;</span><br><span class="line">            countT[c - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历S</span><br><span class="line">        for(char c : S.toCharArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历countT，注意判断条件i &lt; countT[c - &#39;a&#39;]写法，T中有多少个S出现的字符就添加多少次</span><br><span class="line">            for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意清零不影响后面其他S中没有的字符添加</span><br><span class="line">            countT[c - &#39;a&#39;] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 加上T剩余的原先S中没有的字母</span><br><span class="line">        for(char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;</span><br><span class="line">           for(int i &#x3D; 0; i &lt; countT[c - &#39;a&#39;]; i++) &#123;</span><br><span class="line">               res.append(c);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/20200412032101885.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/custom-sort-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/custom-sort-string&lt;/a&gt; 】&lt;/p&gt;
&lt;p&gt;字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。&lt;br&gt;S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。&lt;br&gt;返回任意一种符合条件的字符串T。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入:&lt;br&gt;S = “cba”&lt;br&gt;T = “abcd”&lt;br&gt;输出: “cbad”&lt;br&gt;解释:&lt;br&gt;S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.&lt;br&gt;由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;S的最大长度为26，其中没有重复的字符。&lt;br&gt;T的最大长度为200。&lt;br&gt;S和T只包含小写字符。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>翻转字符串里的单词</title>
    <link href="https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://kawhiz.github.io/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2020-04-10T02:54:46.000Z</published>
    <updated>2020-04-10T03:57:07.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string</a> 】<br>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：<br>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除首位无关空格，再按空白分割成字符串数组，重新反转拼接回去<br>稍微注意java中split(“\s+”)的写法，需要加上转义字符，s+代表匹配包括空格、制表健等空白部分</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 按中间空白部分（包括空格制表键等）分割成String数组</span><br><span class="line">        String[] strArr &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        for(int i &#x3D; strArr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            sb.append(strArr[i]);</span><br><span class="line">            &#x2F;&#x2F; 统一中间加一个空格分割</span><br><span class="line">            if(i &gt; 0) &#123;</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410105915195.png" alt><br><strong>API简洁版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; 通过空白部分分割</span><br><span class="line">        List&lt;String&gt; wordList &#x3D; Arrays.asList(s.split(&quot;\\s+&quot;));</span><br><span class="line">        &#x2F;&#x2F; 反转</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        &#x2F;&#x2F; 重新以单空格拼接回去</span><br><span class="line">        return String.join(&quot; &quot;, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410111721079.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>尽量少使用一些API来提升速度<br>问题的关键在于需要反转同时需要找到不定数目空格分割的单词<br>从字符串尾开始遍历实现反转，设置双指针分别用来记录每个单词的首尾，找到一个则拼接原字符串的子串到结果集里，注意中间统一按一个空格分割</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去除首尾多余空格</span><br><span class="line">        s &#x3D; s.trim();</span><br><span class="line">        &#x2F;&#x2F; i用来记录单词的首字符下标</span><br><span class="line">        int i &#x3D; s.length() - 1;</span><br><span class="line">        &#x2F;&#x2F; j用来记录单词的末字符下标</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 从原字符串尾部开始遍历整个字符串实现反转</span><br><span class="line">        while(i &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到最后一个单词第一个空格分割符</span><br><span class="line">            while(i &gt;&#x3D;0 &amp;&amp; s.charAt(i) !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意substring方法的下标和写法、记得去除最后一个多余的空格</span><br><span class="line">            if(i &gt;&#x3D; 0) &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1) + &quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(s.substring(i + 1, j + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 找到倒数第二个单词最后一个字符</span><br><span class="line">            while(i &gt;&#x3D; 0 &amp;&amp; s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加完重新更新</span><br><span class="line">            j &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/10/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/20200410115331506.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/reverse-words-in-a-string&lt;/a&gt; 】&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入: “the sky is blue”&lt;br&gt;输出: “blue is sky the”&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入: “  hello world!  “&lt;br&gt;输出: “world! hello”&lt;br&gt;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入: “a good   example”&lt;br&gt;输出: “example good a”&lt;br&gt;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;无空格字符构成一个单词。&lt;br&gt;输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。&lt;br&gt;如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>括号生成</title>
    <link href="https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://kawhiz.github.io/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2020-04-09T03:33:19.000Z</published>
    <updated>2020-04-09T04:30:18.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a> 】<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>因为是要生成所有可能的有效括号，类似全排列，自然而然想到用dfs递归搜索<br>n对括号的话，从根节点空字符串开始，一直到搜索到深度2n则记录其中一种情况<br>这里递归参数设为左右括号剩余量，以及当前字符串，递归条件通过有效括号匹配规则剪枝、递归出口就是当左右括号都没有剩余<br><em>问题的关键在于分析以下几种情况</em><br>左右括号都没有剩余，则到底，记录其中一种有效结果<br>左子树生成前提是左括号有剩余<br>右子树生成前提是右括号有剩余，并且要左括号剩余比右括号少才会匹配成功</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回空</span><br><span class="line">        if(n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; dfs搜索根结点为&quot;&quot;</span><br><span class="line">        dfs(n, n, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; left代表剩余左括号数目，right代表剩余右括号数目，String每次都创建一个新对象回溯时不需要恢复现场</span><br><span class="line">    public void dfs(int left, int right, String curStr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左右括号都不剩余代表深度到底，加入结果集</span><br><span class="line">        if(left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左括号剩余则生成左枝</span><br><span class="line">        if(left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr + &quot;(&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右括号剩余，且左括号剩余数目必须小于右括号才有可能匹配有效</span><br><span class="line">        if(right &gt; 0 &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/09/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/20200409120632596.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/generate-parentheses&lt;/a&gt; 】&lt;br&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：n = 3&lt;br&gt;输出：[&lt;br&gt;       “((()))”,&lt;br&gt;       “(()())”,&lt;br&gt;       “(())()”,&lt;br&gt;       “()(())”,&lt;br&gt;       “()()()”&lt;br&gt;     ]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://kawhiz.github.io/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://kawhiz.github.io/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2020-04-08T05:24:50.000Z</published>
    <updated>2020-04-08T05:52:03.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a> 】<br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：<br>输入：m = 2, n = 3, k = 1<br>输出：3</p><p>示例 2：</p><p>输入：m = 3, n = 1, k = 0<br>输出：1<br>提示：</p><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>bfs搜索的常规思想<br>设置方向数组来进行新下标计算，注意越界问题<br>注意这里下标范围是百位数以内的，直接求数位和判断下标是否可达，设置数组记录结点是否访问，未访问可达则入队</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列存放访问结点的横纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    LinkedList&lt;int[]&gt; queue;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放横坐标变化常量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dx &#x3D; &#123;0, 0, -1, 1&#125;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放纵坐标变化常量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int[] dy &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录结点是否访问过</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean[][] used;</span><br><span class="line"></span><br><span class="line">    public int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可达格子数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        used &#x3D; new boolean[m][n];</span><br><span class="line">        queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 先判断(0, 0)是否满足数位和不大于k</span><br><span class="line">        if (k &gt;&#x3D; 0) &#123;</span><br><span class="line">            queue.offer(new int[]&#123;0, 0&#125;);</span><br><span class="line">            used[0][0] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前结点</span><br><span class="line">            int[] curNode &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F; 横坐标</span><br><span class="line">            int x &#x3D; curNode[0];</span><br><span class="line">            &#x2F;&#x2F; 纵坐标</span><br><span class="line">            int y &#x3D; curNode[1];</span><br><span class="line">            boolean flag &#x3D; (sum(x) + sum(y) &lt;&#x3D; k);</span><br><span class="line">            &#x2F;&#x2F; 如果当前结点数位和不大于k代表可达</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 四个方向的横纵坐标变化</span><br><span class="line">            for (int i &#x3D; 0; i &lt; dx.length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前结点移动一次后新横坐标</span><br><span class="line">                int tx &#x3D; x + dx[i];</span><br><span class="line">                &#x2F;&#x2F; 当前结点移动一次后新纵坐标</span><br><span class="line">                int ty &#x3D; y + dy[i];</span><br><span class="line">                &#x2F;&#x2F; 判断是否越界</span><br><span class="line">                if (tx &lt; m &amp;&amp; ty &lt; n &amp;&amp; tx &gt;&#x3D; 0 &amp;&amp; ty &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 未访问且可达将结点入队，设置已访问</span><br><span class="line">                    if (!used[tx][ty] &amp;&amp; flag) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;tx, ty&#125;);</span><br><span class="line">                        used[tx][ty] &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 求数位和</span><br><span class="line">     *</span><br><span class="line">     * @param x</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int sum(int x) &#123;</span><br><span class="line">        int sumX &#x3D; 0;</span><br><span class="line">        while(x &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 累加上最低位的值</span><br><span class="line">            sumX +&#x3D; x % 10;</span><br><span class="line">            &#x2F;&#x2F; 舍弃低位</span><br><span class="line">            x &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sumX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/08/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/20200408012826997.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof&lt;/a&gt; 】&lt;br&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：m = 2, n = 3, k = 1&lt;br&gt;输出：3&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：m = 3, n = 1, k = 0&lt;br&gt;输出：1&lt;br&gt;提示：&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= n,m &amp;lt;= 100&lt;br&gt;0 &amp;lt;= k &amp;lt;= 20&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>旋转矩阵</title>
    <link href="https://kawhiz.github.io/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://kawhiz.github.io/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-07T04:12:00.000Z</published>
    <updated>2020-04-07T05:17:59.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-matrix-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci</a> 】<br>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p>示例 1:<br>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><p>示例 2:<br>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>一开始直观的想另开一个数组存放每一个像素点顺时针旋转90度后的结果，最后再复制回去即可，没想到这样就双百了。。。。。。<br>问题的关键是找到顺时针旋转90度后每一个下标变化的规律，多写几个还是不难发现的</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">        int n &#x3D; matrix.length;</span><br><span class="line">        &#x2F;&#x2F; 额外开数组存放结果</span><br><span class="line">        int[][] res &#x3D; new int[n][n];</span><br><span class="line">        &#x2F;&#x2F; 顺时针旋转90度</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 每一处顺时针90度旋转下标的变化</span><br><span class="line">                res[j][n - i - 1] &#x3D; matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 复制回去</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[i][j] &#x3D; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/20200407121523278.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>另一种思路是矩阵通过对角线上下调换后，再左右对调也可达成同样的效果</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">        int n &#x3D; matrix.length;</span><br><span class="line">        int temp &#x3D; - 1;</span><br><span class="line">        &#x2F;&#x2F; 通过&quot;左上-右下&quot;对角线上下调换</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">                matrix[j][i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; - 1;</span><br><span class="line">        &#x2F;&#x2F; 左右调换</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n ; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; (n &gt;&gt; 1); j++, k--) &#123;</span><br><span class="line">                temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[i][k];</span><br><span class="line">                matrix[i][k] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/07/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/20200407010804117.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-matrix-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotate-matrix-lcci&lt;/a&gt; 】&lt;br&gt;给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;/p&gt;
&lt;p&gt;不占用额外内存空间能否做到？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;给定 matrix =&lt;br&gt;[&lt;br&gt;  [1,2,3],&lt;br&gt;  [4,5,6],&lt;br&gt;  [7,8,9]&lt;br&gt;],&lt;br&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;[&lt;br&gt;  [7,4,1],&lt;br&gt;  [8,5,2],&lt;br&gt;  [9,6,3]&lt;br&gt;]&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;给定 matrix =&lt;br&gt;[&lt;br&gt;  [ 5, 1, 9,11],&lt;br&gt;  [ 2, 4, 8,10],&lt;br&gt;  [13, 3, 6, 7],&lt;br&gt;  [15,14,12,16]&lt;br&gt;],&lt;br&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;[&lt;br&gt;  [15,13, 2, 5],&lt;br&gt;  [14, 3, 4, 1],&lt;br&gt;  [12, 6, 8, 9],&lt;br&gt;  [16, 7,10,11]&lt;br&gt;]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后的hexo恢复</title>
    <link href="https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/"/>
    <id>https://kawhiz.github.io/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/</id>
    <published>2020-04-07T02:18:44.000Z</published>
    <updated>2020-04-07T03:13:23.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>win10重装系统后hexo博客如何恢复？</strong></p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="重装nodejs、git"><a href="#重装nodejs、git" class="headerlink" title="重装nodejs、git"></a>重装nodejs、git</h2><p><strong>去官网下载LTS版本</strong><br>node：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a><br>git：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a> 【git官网下载太慢可以在这里下载】</p><h2 id="重装hexo-cli"><a href="#重装hexo-cli" class="headerlink" title="重装hexo-cli"></a>重装hexo-cli</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-cli -g</code></p><h2 id="重新配置git个人信息、生成ssh密钥"><a href="#重新配置git个人信息、生成ssh密钥" class="headerlink" title="重新配置git个人信息、生成ssh密钥"></a>重新配置git个人信息、生成ssh密钥</h2><p><strong>git bash输入以下命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your github name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;your email&quot;</span><br></pre></td></tr></table></figure><p><strong>在提示文件夹处找到ssh密钥</strong><br><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407110652561.png" alt><br><strong>github上设置好ssh后不用每次git操作时都要提示输入账号密码</strong><br><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407110957452.png" alt></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103533188.png" alt></p><h2 id="保留删除文件"><a href="#保留删除文件" class="headerlink" title="保留删除文件"></a>保留删除文件</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407103959930.png" alt></p><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><p><img src="/2020/04/07/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84hexo%E6%81%A2%E5%A4%8D/20200407104150066.png" alt></p><h2 id="安装部署依赖"><a href="#安装部署依赖" class="headerlink" title="安装部署依赖"></a>安装部署依赖</h2><p><strong>在选定的博客文件夹根目录git bash安装</strong><br><code>npm install hexo-deployer-git --save</code></p><h2 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h2><p><strong>执行完去看看是否推送成功</strong><br><code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;win10重装系统后hexo博客如何恢复？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://kawhiz.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://kawhiz.github.io/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-06T08:52:43.000Z</published>
    <updated>2020-04-06T09:47:36.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a> 】<br>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p>示例 2：<br>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>题目给了三种操作，直观发现对A（B）插入等价于对B（A）删除、对A替换等价于对B替换，操作的顺序不影响结果<br>一开始的直观想法采用BFS搜索每种操作的情况，但是考虑可能会及其耗时<br>由于是要找最优解，若问题含有最优子结构性质可以考虑使用动态规划来解决<br>设置一个二维数组dp(i)(j)代表代表A中前i个字母转换为B中前j个字母的最少操作次数<br>dp（i，j）问题的关键在于考虑d（i - 1， j）【d（i， j - 1）】只要再执行一次插入【删除】操作子问题和dp（i - 1， j - 1)是否需要再执行一次替换操作两者的最小值<br>拿A = “horse”和B = “ros”示例，过程如图</strong><br><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406054735596.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加一是为了判断空字符串的情况</span><br><span class="line">        int m &#x3D; word1.length() + 1;</span><br><span class="line">        int n &#x3D; word2.length() + 1;</span><br><span class="line">        &#x2F;&#x2F; 存放A中前m个和B中前n个字母得的少操作次数</span><br><span class="line">        int[][] dp &#x3D; new int[m][n];</span><br><span class="line">        &#x2F;&#x2F; 直观看到，如果其中一个为空字符串，那么操作次数取决于另一个的长度</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 同上</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断A、B中最后一个字符串是否相等</span><br><span class="line">                char ci &#x3D; word1.charAt(i - 1);</span><br><span class="line">                char cj &#x3D; word2.charAt(j - 1);</span><br><span class="line">                &#x2F;&#x2F; 若相等代表A、B在替换操作时跟其去除当前最后一个字母的情况相等</span><br><span class="line">                if(ci &#x3D;&#x3D; cj) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1]);</span><br><span class="line">                    &#x2F;&#x2F; 区别在于比较的最后一项多了加一（次操作）</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/06/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/20200406045859234.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>求最优解一开始没往dp方向想，走了很多弯路。。。。。。</li><li>在分析好最优子结构和状态后，写完状态转化方程后，稍微考虑一下边界问题，很快就能编码解决问题，所以在动手之前还是要把问题分析清楚</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/edit-distance&lt;/a&gt; 】&lt;br&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;br&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：word1 = “horse”, word2 = “ros”&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;horse -&amp;gt; rorse (将 ‘h’ 替换为 ‘r’)&lt;br&gt;rorse -&amp;gt; rose (删除 ‘r’)&lt;br&gt;rose -&amp;gt; ros (删除 ‘e’)&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：word1 = “intention”, word2 = “execution”&lt;br&gt;输出：5&lt;br&gt;解释：&lt;br&gt;intention -&amp;gt; inention (删除 ‘t’)&lt;br&gt;inention -&amp;gt; enention (将 ‘i’ 替换为 ‘e’)&lt;br&gt;enention -&amp;gt; exention (将 ‘n’ 替换为 ‘x’)&lt;br&gt;exention -&amp;gt; exection (将 ‘n’ 替换为 ‘c’)&lt;br&gt;exection -&amp;gt; execution (插入 ‘u’)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://kawhiz.github.io/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-05T14:41:05.000Z</published>
    <updated>2020-04-05T14:56:51.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a> 】<br>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:<br>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>实现LRU的话关键在于如何判断移除哪个键值是最近最少未使用的，直观思路就是设置上次使用的时间戳以及使用次数<br>不过自己代码封装及其丑陋。。。<br>所以还是参考官方使用java已经封装得非常好看的LinkedHashMap，因为底层通过封装哈希表和双向链表保证了有序插入，同时实现了removeEldestEntry方法，这里cache容量满了的话要删除头部结点就是最近最少未使用的结点</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; cache的容量</span><br><span class="line">    private int capacity;</span><br><span class="line">    &#x2F;&#x2F; super(capacity, 0.75F, true)这里三个参数分别是容量、负载因子和模式，默认为插入模式存储，这里设置为访问模式存储</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        super(capacity, 0.75F, true);</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; super.getOrDefault(key, -1)这里如果查不到则返回默认值-1</span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        return super.getOrDefault(key, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        super.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果当前大小大于容量则需要移除最近最少使用的结点</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj &#x3D; new LRUCache(capacity);</span><br><span class="line"> * int param_1 &#x3D; obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/05/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/20200405105618555.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/lru-cache&lt;/a&gt; 】&lt;br&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;p&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );&lt;/p&gt;
&lt;p&gt;cache.put(1, 1);&lt;br&gt;cache.put(2, 2);&lt;br&gt;cache.get(1);       // 返回  1&lt;br&gt;cache.put(3, 3);    // 该操作会使得密钥 2 作废&lt;br&gt;cache.get(2);       // 返回 -1 (未找到)&lt;br&gt;cache.put(4, 4);    // 该操作会使得密钥 1 作废&lt;br&gt;cache.get(1);       // 返回 -1 (未找到)&lt;br&gt;cache.get(3);       // 返回  3&lt;br&gt;cache.get(4);       // 返回  4&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://kawhiz.github.io/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-04-04T03:31:37.000Z</published>
    <updated>2020-04-04T06:09:02.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a> 】<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png" alt><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>看图可以直观发现每一个柱子高度接水量跟左右两边柱子的最大高度相关<br>当前柱子接水量等于左右两边最大高度中的最小值减去当前高度<br>这里直接简单粗暴两边遍历算出各自最大值再拿最小值来计算最后累加每一个柱子接水量即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前高度左边的最大值</span><br><span class="line">        int maxLeft &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 当前高度右边的最大值</span><br><span class="line">        int maxRight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 一个往右一个往左、注意边界判断即可</span><br><span class="line">            int j &#x3D; i + 1, k &#x3D; i - 1;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往右查找右边最大高度</span><br><span class="line">            while(j &lt; n) &#123;</span><br><span class="line">                maxRight &#x3D; Math.max(height[j], maxRight);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度往左查找左边最大高度</span><br><span class="line">            while(k &gt; -1) &#123;</span><br><span class="line">                maxLeft &#x3D; Math.max(height[k], maxLeft);</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量     </span><br><span class="line">            int temp &#x3D; (Math.min(maxRight, maxLeft) - height[i]);</span><br><span class="line">            if(temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意重新归零</span><br><span class="line">            maxRight &#x3D; 0;</span><br><span class="line">            maxLeft &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404114109687.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路I"><a href="#思路I" class="headerlink" title="思路I"></a>思路I</h2><p><strong>可以额外开数组记录中间结果而不用每次都在循环内再循环遍历左右最大值，拿极小的空间代价换取时间</strong></p><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n &#x3D; height.length;</span><br><span class="line">        &#x2F;&#x2F; 至少要三个高度才能接水</span><br><span class="line">        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 总水量</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 分别存放i左右两边的最大值</span><br><span class="line">        int[] maxLeft &#x3D; new int[n];</span><br><span class="line">        int[] maxRight &#x3D; new int[n];</span><br><span class="line">        &#x2F;&#x2F; 最左边的左边以及最右边的右边最大值都为0</span><br><span class="line">        maxLeft[0] &#x3D; 0;</span><br><span class="line">        maxRight[n - 1] &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 记录i左边的最大值</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            maxLeft[i] &#x3D; Math.max(height[i - 1], maxLeft[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录i右边的最大值</span><br><span class="line">        for (int i &#x3D; n - 2; i &gt; 0; i--) &#123;</span><br><span class="line">            maxRight[i] &#x3D; Math.max(height[i + 1], maxRight[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; i是当前高度的下标</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前高度接水的量</span><br><span class="line">            int temp &#x3D; (Math.min(maxRight[i], maxLeft[i]) - height[i]);</span><br><span class="line">            if (temp &gt; 0) &#123;</span><br><span class="line">                res +&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404015530001.png" alt></p><h2 id="思路II"><a href="#思路II" class="headerlink" title="思路II"></a>思路II</h2><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt; 】&lt;br&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;&lt;img src=&quot;/2020/04/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/20200404113338334.png&quot; alt&gt;&lt;br&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;输出: 6&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字符串转换整数atoi</title>
    <link href="https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/"/>
    <id>https://kawhiz.github.io/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/</id>
    <published>2020-04-03T07:30:08.000Z</published>
    <updated>2020-04-03T07:53:29.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a> 】<br>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:<br>输入: “42”<br>输出: 42</p><p>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先去除多余的空格然后记录正负号，千万注意对Integer越界情况进行判断<br>问题的关键在于res = res * 10 + num &gt; Integer.MAX_VALUE这里计算出来的结果可能越界所以必须先判断再计算最后根据正负号对应添加符号<br>int num = c - ‘0’;这里通过ASCII计算可以将char c转化为对应的int</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 去前面和后面多余的空格</span><br><span class="line">        str &#x3D; str.trim();</span><br><span class="line">        &#x2F;&#x2F; 空字符串直接返回无效</span><br><span class="line">        if(&quot;&quot;.equals(str)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否负数</span><br><span class="line">        boolean isNegative &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 字符串下标</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        char c &#x3D; str.charAt(i);</span><br><span class="line">        &#x2F;&#x2F; 遇到负号</span><br><span class="line">        if(c &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            isNegative &#x3D; true;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到正号</span><br><span class="line">        &#125; else if(c &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#x2F;&#x2F; 遇到无效数字</span><br><span class="line">        &#125; else if(!Character.isDigit(c)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 结果</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 遇到0 ~ 9</span><br><span class="line">        while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i))) &#123;</span><br><span class="line">            c &#x3D; str.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 将字符转化为int</span><br><span class="line">            int num &#x3D; c - &#39;0&#39;;</span><br><span class="line">            &#x2F;&#x2F; 当res * 10 + num &gt; Integer.MAX_VALUE越界、所以先判断res的范围</span><br><span class="line">            if (res &gt; (Integer.MAX_VALUE - num) &#x2F; 10) &#123;</span><br><span class="line">                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不越界则正常加</span><br><span class="line">            res &#x3D; res * 10 + num;</span><br><span class="line">            &#x2F;&#x2F; 判断下一个</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return isNegative ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0atoi/20200403033744892.png" alt></p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>我一开始考虑使用一个StringBuffer来接受结果但是判断越界的时候又需要重新转化非常麻烦所以用int来接受结果是比较好的</li><li>我一开始自己写了去除空格的判断以及是否为数字的判断导致代码非常臃肿难看低效，因此这里都用String.trim()、Character.isDigit()这些库函数代替</li><li>稍微注意一下下标越界问题**</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/string-to-integer-atoi&lt;/a&gt; 】&lt;br&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;br&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：&lt;br&gt;如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。&lt;br&gt;假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。&lt;br&gt;该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。&lt;br&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。&lt;br&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0 。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;本题中的空白字符只包括空格字符 ‘ ‘ 。&lt;br&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “42”&lt;br&gt;输出: 42&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;输入: “   -42”&lt;br&gt;输出: -42&lt;br&gt;解释: 第一个非空白字符为 ‘-‘, 它是一个负号。&lt;br&gt;     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;输入: “4193 with words”&lt;br&gt;输出: 4193&lt;br&gt;解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。&lt;/p&gt;
&lt;p&gt;示例 4:&lt;br&gt;输入: “words and 987”&lt;br&gt;输出: 0&lt;br&gt;解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。&lt;br&gt;     因此无法执行有效的转换。&lt;/p&gt;
&lt;p&gt;示例 5:&lt;br&gt;输入: “-91283472332”&lt;br&gt;输出: -2147483648&lt;br&gt;解释: 数字 “-91283472332” 超过 32 位有符号整数范围。&lt;br&gt;     因此返回 INT_MIN (−231) 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>生命游戏</title>
    <link href="https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://kawhiz.github.io/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-02T11:13:46.000Z</published>
    <updated>2020-04-02T12:38:43.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/game-of-life" target="_blank" rel="noopener">https://leetcode-cn.com/problems/game-of-life</a> 】<br>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：<br>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]<br>进阶：<br>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。<br>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>可以考虑采用bfs搜索，备份原来的状态<br>直接简单粗暴将死细胞和活细胞分别入队然后各自判断周围8个位置活细胞的数目再根据规则修改状态即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 待处理的活细胞或者死细胞、队列存放数组，数组第一位存值，第二位存行数、第三位存列数</span><br><span class="line">    LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">    &#x2F;&#x2F; 存放最终结果</span><br><span class="line">    int[][] res;</span><br><span class="line">    &#x2F;&#x2F; 8个方向数组</span><br><span class="line">    int[] dx &#x3D; &#123;-1, -1, -1, 0, 0, 1, 1, 1&#125;;</span><br><span class="line">    int[] dy &#x3D; &#123;-1, 0, 1, -1, 1, -1, 0, 1&#125;;</span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        res &#x3D; new int[board.length][board[0].length];</span><br><span class="line">        &#x2F;&#x2F; 活细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 1);</span><br><span class="line">        &#x2F;&#x2F; 死细胞入队</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;board[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(board, 0);</span><br><span class="line">        &#x2F;&#x2F; 将结果数组复制回原数组</span><br><span class="line">        for(int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;board[0].length; j++) &#123;</span><br><span class="line">                board[i][j] &#x3D; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; bfs搜索</span><br><span class="line">    public void bfs(int[][] board, int flag) &#123;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] node &#x3D; queue.poll();</span><br><span class="line">            int val &#x3D; node[0];</span><br><span class="line">            int i &#x3D; node[1];</span><br><span class="line">            int j &#x3D; node[2];</span><br><span class="line">            int count1 &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F; 统计旁边八个位置的活细胞数目</span><br><span class="line">            for (int k &#x3D; 0; k &lt; 8; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 横坐标</span><br><span class="line">                int tx &#x3D; i + dx[k];</span><br><span class="line">                &#x2F;&#x2F; 纵坐标</span><br><span class="line">                int ty &#x3D; j + dy[k];</span><br><span class="line">                &#x2F;&#x2F; 越界则跳过</span><br><span class="line">                if (tx &lt; 0 || tx &gt;&#x3D; board.length || ty &lt; 0 || ty &gt;&#x3D; board[0].length) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[tx][ty] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 活细胞周围细胞数小于2或者大于3死亡、等于2或者等于3仍然存活；</span><br><span class="line">            if (flag &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                if (count1 &lt; 2 || count1 &gt; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 2 || count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 死细胞周围有三个活细胞则复活</span><br><span class="line">            if (flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (count1 &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                    res[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 注意活细胞数清零</span><br><span class="line">            count1 &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402072054309.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>因为额外开数组和各自判断对速度和内存影响极大，但是为了同时记录活细胞和死细胞当下和先前的状态从而不影响活细胞数目判断，可以考虑自己设置其他状态码<br>这里用-1代表从活细胞到死细胞、2代表从死细胞到活细胞，最后处理完注意更新新状态<br>8个位置的横纵坐标变化只有1，0，-1，但是要注意排除0，0（自身）的情况</strong></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从活细胞到死细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int liveToDead &#x3D; -1;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从死细胞到活细胞的状态码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int deadToLive &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 3个坐标值变化数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int[] change &#x3D; &#123;0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 行数</span><br><span class="line">        int m &#x3D; board.length;</span><br><span class="line">        &#x2F;&#x2F; 列数</span><br><span class="line">        int n &#x3D; board[0].length;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 开始从第一个细胞遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 周围8个位置活细胞数目</span><br><span class="line">                int countLive &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 对每个细胞周围8个方向判断</span><br><span class="line">                for (int k &#x3D; 0; k &lt; change.length; k++) &#123;</span><br><span class="line">                    for (int l &#x3D; 0; l &lt; change.length; l++) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 排除当前细胞自身</span><br><span class="line">                        if (change[k] !&#x3D; 0 || change[l] !&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 周围位置横坐标</span><br><span class="line">                            int x &#x3D; (i + change[k]);</span><br><span class="line">                            &#x2F;&#x2F; 周围位置纵坐标</span><br><span class="line">                            int y &#x3D; (j + change[l]);</span><br><span class="line">                            &#x2F;&#x2F; 不越界的情况下周围是否有活细胞、注意判断要包括活细胞到死细胞这种情况</span><br><span class="line">                            boolean hasLiveCell &#x3D; (x &gt;&#x3D; 0 &amp;&amp; x &lt; m) &amp;&amp; (y &gt;&#x3D; 0 &amp;&amp; y &lt; n) &amp;&amp; (board[x][y] &#x3D;&#x3D; 1 || board[x][y] &#x3D;&#x3D; liveToDead);</span><br><span class="line">                            if (hasLiveCell) &#123;</span><br><span class="line">                                countLive++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 活细胞到死细胞</span><br><span class="line">                if (countLive &lt; 2 || countLive &gt; 3) &#123;</span><br><span class="line">                    if (board[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        board[i][j] &#x3D; liveToDead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 死细胞到活细胞</span><br><span class="line">                if (countLive &#x3D;&#x3D; 3 &amp;&amp; board[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    board[i][j] &#x3D; deadToLive;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取更新后的状态</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; liveToDead) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; deadToLive) &#123;</span><br><span class="line">                    board[i][j] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/20200402083733078.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/game-of-life&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/game-of-life&lt;/a&gt; 】&lt;br&gt;根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。&lt;/p&gt;
&lt;p&gt;给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：&lt;/p&gt;
&lt;p&gt;如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；&lt;br&gt;如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；&lt;br&gt;如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；&lt;br&gt;如果死细胞周围正好有三个活细胞，则该位置死细胞复活；&lt;br&gt;根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;[&lt;br&gt;  [0,1,0],&lt;br&gt;  [0,0,1],&lt;br&gt;  [1,1,1],&lt;br&gt;  [0,0,0]&lt;br&gt;]&lt;br&gt;输出：&lt;br&gt;[&lt;br&gt;  [0,0,0],&lt;br&gt;  [1,0,1],&lt;br&gt;  [0,1,1],&lt;br&gt;  [0,1,0]&lt;br&gt;]&lt;br&gt;进阶：&lt;br&gt;你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。&lt;br&gt;本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://kawhiz.github.io/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-04-01T08:32:31.000Z</published>
    <updated>2020-04-01T09:41:39.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a> 】<br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>左右括号必须一一匹配，可以考虑使用栈辅助存放所有左括号然后遇到一个右括号弹出栈顶元素判断是否匹配，最后栈空代表一一匹配成功<br>惯性思维考虑map的key存放左括号、value存放右括号，这样让左括号入栈后，每次遍历到一个右括号和栈顶的元素判断是否相等比key存放右括号、value存放左括号麻烦，时间慢了2倍</strong></p><h1 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放右括号、value存放左括号</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;)&#39;, &#39;(&#39;);</span><br><span class="line">        map.put(&#39;]&#39;, &#39;[&#39;);</span><br><span class="line">        map.put(&#39;&#125;&#39;, &#39;&#123;&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 让左括号入栈</span><br><span class="line">            if(!map.containsKey(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 栈顶是左括号</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                if(top !&#x3D; map.get(c)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401043902216.png" alt></p><h1 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 辅助栈存放左括号</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();</span><br><span class="line">        &#x2F;&#x2F; map存放匹配的左右字符、key存放左括号、value存放右括号、这里注意跟方案I的区别</span><br><span class="line">        HashMap&lt;Character, Character&gt; map &#x3D; new HashMap&lt;Character, Character&gt;();</span><br><span class="line">        map.put(&#39;(&#39;, &#39;)&#39;);</span><br><span class="line">        map.put(&#39;[&#39;, &#39;]&#39;);</span><br><span class="line">        map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);</span><br><span class="line">        &#x2F;&#x2F; 防止map.get(key)异常</span><br><span class="line">        map.put(&#39;X&#39;, &#39;X&#39;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            &#x2F;&#x2F; 左括号入栈、这里注意跟方案I的区别</span><br><span class="line">            if(!map.containsValue(c)) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                &#x2F;&#x2F; 中间判断时栈为空则代表缺失左括号，匹配失败</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里注意判断栈为空代表只有单独的右括号，所以匹配失败</span><br><span class="line">                char top &#x3D; stack.isEmpty() ? &#39;X&#39; : stack.pop();</span><br><span class="line">                &#x2F;&#x2F; 这里注意跟方案I的区别</span><br><span class="line">                if(c !&#x3D; map.get(top)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最终栈空代表全部匹配完</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20200401045523605.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/valid-parentheses&lt;/a&gt; 】&lt;br&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;br&gt;有效字符串需满足：&lt;br&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;注意空字符串可被认为是有效字符串。&lt;br&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: “()”&lt;br&gt;输出: true&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: “()[]{}”&lt;br&gt;输出: true&lt;br&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: “(]”&lt;br&gt;输出: false&lt;br&gt;示例 4:&lt;/p&gt;
&lt;p&gt;输入: “([)]”&lt;br&gt;输出: false&lt;br&gt;示例 5:&lt;/p&gt;
&lt;p&gt;输入: “{[]}”&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://kawhiz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://kawhiz.github.io/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://kawhiz.github.io/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-01T01:23:43.000Z</published>
    <updated>2020-04-01T08:32:58.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>简单粗暴直接全部遍历一遍<br>在每一行使用二分查找<br>我这里一开始试了一下用bfs搜索解题，其实完全没必要<br>拿右上角的数作基准，目标数大往下找，目标数小往左找</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; bfs</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        if(array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[0].length &gt; 0) &#123;</span><br><span class="line">            int m &#x3D; array.length;</span><br><span class="line">            int n &#x3D; array[0].length; </span><br><span class="line">            &#x2F;&#x2F; 存放是否访问过该结点</span><br><span class="line">            boolean[][] used &#x3D; new boolean[m][n];</span><br><span class="line">            LinkedList&lt;int[]&gt; queue &#x3D; new LinkedList&lt;int[]&gt;();</span><br><span class="line">            &#x2F;&#x2F; 数组中前三个数分别代表值，横坐标，纵坐标</span><br><span class="line">            queue.offer(new int[]&#123;array[0][0], 0, 0&#125;);</span><br><span class="line">            while(!queue.isEmpty()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当前结点</span><br><span class="line">                int[] node &#x3D; queue.poll();</span><br><span class="line">                if(node[0] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                int i &#x3D; node[1];</span><br><span class="line">                int j &#x3D; node[2];</span><br><span class="line">                &#x2F;&#x2F; 向右搜索</span><br><span class="line">                if(i &lt; m &amp;&amp; j &lt; n - 1) &#123;</span><br><span class="line">                    if(!used[i][j + 1]) &#123;</span><br><span class="line">                        used[i][j + 1] &#x3D; true;</span><br><span class="line">                        queue.offer(new int[]&#123;array[i][j + 1], i, j + 1&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 向下搜索</span><br><span class="line">                if(i &lt; m - 1 &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                    if(!used[i + 1][j]) &#123;</span><br><span class="line">                        used[i + 1][j] &#x3D; true;</span><br><span class="line">                        queue.offer(new int[]&#123;array[i + 1][j], i + 1, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102256555.png" alt></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="方案I"><a href="#方案I" class="headerlink" title="方案I"></a>方案I</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 二分查找</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean binarySearch(int target, int[][] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每一行二分查找</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; array[0].length - 1;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int mid &#x3D; (low + high) &gt;&gt; 1;</span><br><span class="line">            if (array[i][mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (array[i][mid] &lt; target) &#123;</span><br><span class="line">                low &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102419867.png" alt></p><h2 id="方案II"><a href="#方案II" class="headerlink" title="方案II"></a>方案II</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        if(array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[0].length &gt; 0) &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            int j &#x3D; array[0].length - 1;</span><br><span class="line">            &#x2F;&#x2F; 拿右上角的数作基准,越界则代表找不到</span><br><span class="line">            while (i &lt; array.length &amp;&amp; j &lt; array[0].length &amp;&amp; i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (array[i][j] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                    &#x2F;&#x2F; 目标数小往左找</span><br><span class="line">                &#125; else if (array[i][j] &gt; target) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    &#x2F;&#x2F; 目标数大往下找</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/20200401102808233.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="剑指Offer" scheme="https://kawhiz.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>单词的压缩编码</title>
    <link href="https://kawhiz.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"/>
    <id>https://kawhiz.github.io/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</id>
    <published>2020-03-28T04:41:49.000Z</published>
    <updated>2020-03-28T04:51:55.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/short-encoding-of-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/short-encoding-of-words</a> 】<br>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。<br>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。<br>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。<br>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>示例：<br>输入: words = [“time”, “me”, “bell”]<br>输出: 10<br>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p><p>提示：<br>1 &lt;= words.length &lt;= 2000<br>1 &lt;= words[i].length &lt;= 7<br>每个单词都是小写字母 。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>直观能感受到单词只要能压缩，必须含有相同的后缀，同时注意到重复单词不会影响压缩后的结果<br>可以考虑先用set去重，再对每一个单词扫描找后缀，只要一个单词的后缀包含另一个单词，那么直接去除后者即可<br>最后剩下的都是不能压缩的单词，注意还有”#”，直接累加它们各自的长度+1即找到了压缩后的最小字符串长度</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minimumLengthEncoding(String[] words) &#123;</span><br><span class="line">        &#x2F;&#x2F; 压缩编码后的最小字符串长度</span><br><span class="line">        int minCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 存放不重复的单词</span><br><span class="line">        HashSet&lt;String&gt; set &#x3D; new HashSet&lt;String&gt;(Arrays.asList(words));</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; word.length(); j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 移除相同后缀的单词，稍微注意一下substring的用法</span><br><span class="line">                &#x2F;&#x2F; substring(begin)包括begin到结尾，substring(begin, end)包括begin不包括end</span><br><span class="line">                set.remove(word.substring(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历剩下不重复后缀单词</span><br><span class="line">        for (String str : set) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意还有&quot;#&quot;,所以每次加一</span><br><span class="line">            minCount +&#x3D; str.length() + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return minCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/28/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/20200328124416459.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/short-encoding-of-words&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/short-encoding-of-words&lt;/a&gt; 】&lt;br&gt;给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。&lt;br&gt;例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。&lt;br&gt;对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。&lt;br&gt;那么成功对给定单词列表进行编码的最小字符串长度是多少呢？&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输入: words = [“time”, “me”, “bell”]&lt;br&gt;输出: 10&lt;br&gt;说明: S = “time#bell#” ， indexes = [0, 2, 5] 。&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= words.length &amp;lt;= 2000&lt;br&gt;1 &amp;lt;= words[i].length &amp;lt;= 7&lt;br&gt;每个单词都是小写字母 。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>卡牌分组</title>
    <link href="https://kawhiz.github.io/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/"/>
    <id>https://kawhiz.github.io/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</id>
    <published>2020-03-27T04:16:12.000Z</published>
    <updated>2020-03-27T04:25:46.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards</a> 】<br>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。</p><p>示例 1：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p><p>示例 2：<br>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p><p>示例 3：<br>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。</p><p>示例 4：<br>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]</p><p>示例 5：<br>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]</p><p>提示：<br>1 &lt;= deck.length &lt;= 10000<br>0 &lt;= deck[i] &lt; 10000</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>首先考虑使用一维数组存放出现的次数<br>只要有出现次数为1的分组不成功，所有出现次数的最大公约数必须不小于2才能分组成功</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasGroupsSizeX(int[] deck) &#123;</span><br><span class="line">        &#x2F;&#x2F; 排序方便取最大值，同时执行速度大幅提升</span><br><span class="line">        Arrays.sort(deck);</span><br><span class="line">        &#x2F;&#x2F; 存放每个数的出现次数</span><br><span class="line">        int[] count &#x3D; new int[deck[deck.length - 1] + 1];</span><br><span class="line">        &#x2F;&#x2F; 统计每个数的出现次数</span><br><span class="line">        for(int i &#x3D; 0; i &lt; deck.length; i++) &#123;</span><br><span class="line">            count[deck[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 排序执行速度翻倍</span><br><span class="line">        Arrays.sort(count);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; count.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到一个出现次数为1则代表无法分组大于2</span><br><span class="line">            if(count[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 只要满足所有数的最大公因数不小于2则代表可以分组</span><br><span class="line">        for(int i &#x3D; 1; i &lt; count.length; i++) &#123;</span><br><span class="line">            if(count[i - 1] !&#x3D; 0 &amp;&amp; count[i] !&#x3D; 0)&#123;</span><br><span class="line">                if(gcd(count[i], count[i - 1]) &lt; 2 ) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 辗转相除法求最大公因数</span><br><span class="line">    public int gcd(int a, int b) &#123;</span><br><span class="line">        while(a % b !&#x3D; 0) &#123;</span><br><span class="line">            int temp &#x3D; a % b;</span><br><span class="line">            a &#x3D; b;</span><br><span class="line">            b &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/27/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/20200327122546123.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards&lt;/a&gt; 】&lt;br&gt;给定一副牌，每张牌上都写着一个整数。&lt;br&gt;此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：&lt;br&gt;每组都有 X 张牌。&lt;br&gt;组内所有的牌上都写着相同的整数。&lt;br&gt;仅当你可选的 X &amp;gt;= 2 时返回 true。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：[1,2,3,4,4,3,2,1]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：[1,1,1,2,2,2,3,3]&lt;br&gt;输出：false&lt;br&gt;解释：没有满足要求的分组。&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;输入：[1]&lt;br&gt;输出：false&lt;br&gt;解释：没有满足要求的分组。&lt;/p&gt;
&lt;p&gt;示例 4：&lt;br&gt;输入：[1,1]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]&lt;/p&gt;
&lt;p&gt;示例 5：&lt;br&gt;输入：[1,1,2,2,2,2]&lt;br&gt;输出：true&lt;br&gt;解释：可行的分组是 [1,1]，[2,2]，[2,2]&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= deck.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= deck[i] &amp;lt; 10000&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>车的可用捕获量</title>
    <link href="https://kawhiz.github.io/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/"/>
    <id>https://kawhiz.github.io/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/</id>
    <published>2020-03-26T03:32:28.000Z</published>
    <updated>2020-03-26T04:44:13.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/available-captures-for-rook" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook</a> 】<br>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p><p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p><p>返回车能够在一次移动中捕获到的卒的数量。</p><p>【<a href="https://leetcode-cn.com/problems/available-captures-for-rook" target="_blank" rel="noopener">详见链接</a>】</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>题目本来不难解决，但是我感觉题目没有描述得足够清楚，可能有歧义<br>只要先找到白车的位置后再简单粗暴分别向东南西北四个方向找即可</strong></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    *    白车位置的横坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int rx</span><br><span class="line">    &#x2F;**</span><br><span class="line">    *    白车位置的纵坐标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int ry</span><br><span class="line">    public int numRookCaptures1(char[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录白车位置</span><br><span class="line">        findRock(board);</span><br><span class="line">        &#x2F;&#x2F; 车能够在一次移动中捕获到的卒的数量</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 注意没法碾压过去，所以每个方向找到一个黑卒跳出即可</span><br><span class="line">        &#x2F;&#x2F;  扫描东</span><br><span class="line">        for (int j &#x3D; ry; j &lt; board.length; j++) &#123;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 南</span><br><span class="line">        for (int i &#x3D; rx; i &lt; board.length; i++) &#123;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 西</span><br><span class="line">        for (int j &#x3D; ry; j &gt; 0; j--) &#123;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[rx][j] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 北</span><br><span class="line">        for (int i &#x3D; rx; i &gt; 0; i--) &#123;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][ry] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找白车R的位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void findRock(char[][] board) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 只有一个R找到直接结束即可</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">                    rx&#x3D; i;</span><br><span class="line">                    ry&#x3D; j;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326114439690.png" alt></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>可以考虑引入方向数组，存放北南东西四个方向对应的增量<br>向北走每走一步，横坐标rx - 1，ry不变，其余类似如图<br>新横坐标 = 白车横坐标 + step * 对应横坐标方向数组的值，新纵坐标类似</strong><br><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326123607548.png" alt></p><h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int rx,ry;</span><br><span class="line">    public int numRookCaptures(char[][] board) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录白车位置</span><br><span class="line">        findRock(board);</span><br><span class="line">        &#x2F;&#x2F; 分别定义北南东西四个方向得坐标增量</span><br><span class="line">        int[] dx &#x3D; &#123;-1, 1, 0, 0&#125;;</span><br><span class="line">        int[] dy &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">        &#x2F;&#x2F; 车能够在一次移动中捕获到的卒的数量</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 北南东西四个方向依次遍历</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for(int step &#x3D; 1; ; step++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 某一方向上每一步对应坐标</span><br><span class="line">                int tx &#x3D; rx + step * dx[i];</span><br><span class="line">                int ty &#x3D; ry + step * dy[i];</span><br><span class="line">                &#x2F;&#x2F; 越界或者遇到白象跳出该方向</span><br><span class="line">                if(tx &lt; 0 || tx &gt;&#x3D; board.length || ty &lt; 0 || ty &gt;&#x3D; board.length || board[tx][ty] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 遇到黑卒则捕获</span><br><span class="line">                if(board[tx][ty] &#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找白车R的位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void findRock(char[][] board) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; board.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 只要一个R找到直接结束即可</span><br><span class="line">                if (board[i][j] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">                    rx &#x3D; i;</span><br><span class="line">                    ry &#x3D; j;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/26/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/20200326123730207.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/available-captures-for-rook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/available-captures-for-rook&lt;/a&gt; 】&lt;br&gt;在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。&lt;/p&gt;
&lt;p&gt;车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。&lt;/p&gt;
&lt;p&gt;返回车能够在一次移动中捕获到的卒的数量。&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://leetcode-cn.com/problems/available-captures-for-rook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详见链接&lt;/a&gt;】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>三维形体的表面积</title>
    <link href="https://kawhiz.github.io/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/"/>
    <id>https://kawhiz.github.io/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-25T05:11:14.000Z</published>
    <updated>2020-03-25T05:52:00.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>【来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes</a> 】<br>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>请你返回最终形体的表面积。<br>示例 1：</p><p>输入：[[2]]<br>输出：10<br>示例 2：</p><p>输入：[[1,2],[3,4]]<br>输出：34<br>示例 3：</p><p>输入：[[1,0],[0,2]]<br>输出：16<br>示例 4：</p><p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32<br>示例 5：</p><p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p><p>提示：<br>1 &lt;= N &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>某个位置表面积S = 4 * i + 2（i是某个位置的方块个数大于0才统计,四个面乘以方块个数加上上下两个底面）容易直观推导出来<br>重叠侧面面积就是相邻方块数目最小值的两倍<br>遍历时需要分几种情况依次讨论，注意不要遗漏重复即可<br>最后将每个位置的总面积 - 相邻总侧面积即可求出总的表面积</strong><br><img src="/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/20200325013203303.png" alt></p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int surfaceArea ( int[][] grid)&#123;</span><br><span class="line">        &#x2F;&#x2F; 行数</span><br><span class="line">        int row &#x3D; grid.length;</span><br><span class="line">        &#x2F;&#x2F; 列数</span><br><span class="line">        int column &#x3D; grid[0].length;</span><br><span class="line">        &#x2F;&#x2F; 去除上下重叠的面积</span><br><span class="line">        int SumArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 重叠的侧面积</span><br><span class="line">        int lateralArea &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 重叠部分面积数目</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; column; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 注意个数需要大于零才统计该位置</span><br><span class="line">                if(grid[i][j] &gt; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 单个表面积S &#x3D; 4 * n + 2（四个面乘以方块个数加上上下两个底面）</span><br><span class="line">                    SumArea +&#x3D; ((grid[i][j] &lt;&lt; 2) + 2);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 三种情况依次判断统计重叠侧面的数目</span><br><span class="line">                if (i &lt; row - 1 &amp;&amp; j &lt; column - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i][j + 1]);</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i + 1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &#x3D;&#x3D; column - 1 &amp;&amp; i &lt; row - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i + 1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; row - 1 &amp;&amp; j &lt; column - 1) &#123;</span><br><span class="line">                    count +&#x3D; Math.min(grid[i][j], grid[i][j + 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lateralArea &#x3D; count &lt;&lt; 1;</span><br><span class="line">        return SumArea - lateralArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/20200325012738376.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;【来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/surface-area-of-3d-shapes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/surface-area-of-3d-shapes&lt;/a&gt; 】&lt;br&gt;在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。&lt;br&gt;每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。&lt;br&gt;请你返回最终形体的表面积。&lt;br&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：[[2]]&lt;br&gt;输出：10&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：[[1,2],[3,4]]&lt;br&gt;输出：34&lt;br&gt;示例 3：&lt;/p&gt;
&lt;p&gt;输入：[[1,0],[0,2]]&lt;br&gt;输出：16&lt;br&gt;示例 4：&lt;/p&gt;
&lt;p&gt;输入：[[1,1,1],[1,0,1],[1,1,1]]&lt;br&gt;输出：32&lt;br&gt;示例 5：&lt;/p&gt;
&lt;p&gt;输入：[[2,2,2],[2,1,2],[2,2,2]]&lt;br&gt;输出：46&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;1 &amp;lt;= N &amp;lt;= 50&lt;br&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 50&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="每日一题" scheme="https://kawhiz.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
</feed>
